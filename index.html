<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest Todo - Productivity RPG</title>
    <style>
        :root {
            --primary: #4f46e5;
            --secondary: #818cf8;
            --success: #22c55e;
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #0ea5e9;
            --rare: #9333ea;
            --epic: #c026d3;
            --legendary: #fbbf24;
            --focus: #7dd3fc;
            --rest: #f43f5e;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f3f4f6;
            color: #1f2937;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .stats {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .credits {
            background: var(--primary);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }

        .streak {
            background: var(--warning);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }

        .level {
            background: var(--info);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .card {
            background: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .card h2 {
            margin-top: 0;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 0.5rem;
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(1px);
        }

        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        input, select {
            width: 100%;
            padding: 0.5rem;
            margin-bottom: 1rem;
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
        }

        .task-list, .wishlist {
            list-style: none;
            padding: 0;
        }

        .task-list li, .wishlist li {
            background: #f9fafb;
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .task-list li:hover, .wishlist li:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .common {
            border-left: 4px solid #9ca3af;
        }

        .uncommon {
            border-left: 4px solid var(--success);
        }

        .rare {
            border-left: 4px solid var(--rare);
        }

        .epic {
            border-left: 4px solid var(--epic);
        }

        .legendary {
            border-left: 4px solid var(--legendary);
            background: linear-gradient(to right, #fef3c7, #f9fafb 30%);
        }

        .progress-bar {
            background: #e5e7eb;
            height: 1rem;
            border-radius: 0.5rem;
            overflow: hidden;
            margin-top: 0.5rem;
            position: relative;
        }

        .progress-bar-fill {
            background: var(--success);
            height: 100%;
            transition: width 0.3s ease;
        }

        .milestone {
            position: absolute;
            height: 100%;
            width: 2px;
            background: var(--warning);
        }

        .tooltip {
            position: relative;
            display: inline-block;
            margin-left: 0.5rem;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .reward-notification {
            background: var(--primary);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-size: 1.25rem;
            font-weight: bold;
            transition: transform 0.5s, opacity 0.5s;
            transform: translateY(20px);
            opacity: 0;
        }

        .dice-roll {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 1rem 0;
            gap: 1rem;
            height: 0;
            overflow: hidden;
            transition: height 0.3s ease;
        }

        .dice-roll.show {
            height: 60px;
        }

        .dice {
            width: 50px;
            height: 50px;
            background: var(--primary);
            color: white;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            animation: roll 0.75s ease-out;
        }

        @keyframes roll {
            0% { transform: rotateZ(0deg); }
            100% { transform: rotateZ(720deg); }
        }

        .bonus-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            z-index: 1001;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            max-width: 90%;
            width: 400px;
        }

        .bonus-card.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: all;
        }

        .bonus-card-options {
            display: flex;
            justify-content: space-around;
            margin-top: 2rem;
        }

        .bonus-option {
            padding: 1rem;
            border-radius: 0.5rem;
            background: #f9fafb;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            margin: 0 0.5rem;
            border: 2px solid transparent;
        }

        .bonus-option:hover {
            transform: translateY(-2px);
            border-color: var(--primary);
        }

        .level-bar {
            background: #e5e7eb;
            height: 0.5rem;
            border-radius: 0.25rem;
            overflow: hidden;
            margin-top: 0.5rem;
            width: 100px;
        }

        .level-bar-fill {
            background: var(--info);
            height: 100%;
            transition: width 0.3s ease;
        }

        .level-container {
            display: flex;
            align-items: center;
        }

        .loot-table {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .loot-item {
            background: #f9fafb;
            padding: 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .rarity-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .task-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .task-info {
            flex: 1;
        }

        .pomodoro-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .pomodoro-modal.show {
            opacity: 1;
            pointer-events: all;
        }

        .pomodoro-container {
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .timer-display {
            font-size: 3rem;
            text-align: center;
            margin: 2rem 0;
            font-weight: bold;
        }

        .phase-indicator {
            text-align: center;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            font-weight: bold;
        }

        .timer-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .focus-time {
            color: var(--focus);
        }

        .rest-time {
            color: var(--rest);
        }

        .pomodoro-stats {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }

        .pomodoro-progress {
            display: flex;
            margin-top: 1rem;
        }

        .pomodoro-segment {
            flex: 1;
            height: 8px;
            margin: 0 2px;
            border-radius: 4px;
            background: #e5e7eb;
        }

        .pomodoro-segment.completed {
            background: var(--success);
        }

        .pomodoro-segment.current {
            background: var(--focus);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .quest-icon, .reward-icon {
            font-size: 1.5rem;
            margin-right: 0.5rem;
            width: 2rem;
            height: 2rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: #f3f4f6;
            border-radius: 50%;
        }

        .task-header, .reward-header {
            display: flex;
            align-items: center;
        }

        .subtasks {
            margin-top: 0.5rem;
            padding-left: 1rem;
            border-left: 2px dashed #e5e7eb;
        }

        .subtask-item {
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            background: #f3f4f6;
            border-radius: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .subtask-completed {
            text-decoration: line-through;
            opacity: 0.7;
        }

        .pomodoro-btn {
            background: var(--focus);
        }

        .complete-btn {
            background: var(--success);
        }

        .abandon-btn {
            background: var(--danger);
        }

        /* Setup for pomodoro animation */
        .pomodoro-animation {
            width: 100%;
            height: 120px;
            margin-top: 1rem;
            position: relative;
            overflow: hidden;
            background: #000;
            border-radius: 0.5rem;
        }

        .pixel-scene {
            width: 100%;
            height: 100%;
            position: relative;
            image-rendering: pixelated;
        }

        /* Animation elements */
        .character {
            position: absolute;
            bottom: 20px;
            left: 40px;
            width: 24px;
            height: 32px;
            background: #f43f5e;
            animation: characterIdle 1s infinite alternate;
        }

        .forge {
            position: absolute;
            bottom: 10px;
            left: 100px;
            width: 40px;
            height: 30px;
            background: #6b7280;
        }

        .anvil {
            position: absolute;
            bottom: 30px;
            left: 160px;
            width: 30px;
            height: 15px;
            background: #4b5563;
        }

        .hammer {
            position: absolute;
            bottom: 50px;
            left: 165px;
            width: 20px;
            height: 15px;
            background: #9ca3af;
            transform-origin: 50% 100%;
            animation: hammerSwing 1s infinite;
        }

        .sparks {
            position: absolute;
            bottom: 50px;
            left: 175px;
            width: 2px;
            height: 2px;
            background: #fbbf24;
            border-radius: 50%;
            opacity: 0;
            animation: sparksFly 0.5s infinite;
        }

        .magic-circle {
            position: absolute;
            bottom: 10px;
            right: 50px;
            width: 40px;
            height: 10px;
            border: 2px solid #818cf8;
            border-radius: 50%;
            opacity: 0.7;
            animation: magicPulse 2s infinite;
        }

        .magic-particles {
            position: absolute;
            bottom: 30px;
            right: 70px;
            width: 3px;
            height: 3px;
            background: #818cf8;
            border-radius: 50%;
            animation: particleFloat 3s infinite;
        }

        @keyframes characterIdle {
            0% { transform: translateY(0); }
            100% { transform: translateY(-3px); }
        }

        @keyframes hammerSwing {
            0% { transform: rotate(-30deg); }
            10% { transform: rotate(-30deg); }
            20% { transform: rotate(30deg); }
            30% { transform: rotate(-30deg); }
            100% { transform: rotate(-30deg); }
        }

        @keyframes sparksFly {
            0% { opacity: 0; transform: translate(0, 0); }
            20% { opacity: 1; }
            100% { opacity: 0; transform: translate(10px, -20px); }
        }

        @keyframes magicPulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 0.9; }
            100% { transform: scale(1); opacity: 0.7; }
        }

        @keyframes particleFloat {
            0% { transform: translate(0, 0); opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { transform: translate(-30px, -40px); opacity: 0; }
        }

        /* Pomodoro setup screens */
        .pomodoro-setup {
            padding: 1rem;
            background: #f9fafb;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }

        .pomodoro-setup h3 {
            margin-top: 0;
        }

        .time-selector {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .time-option {
            flex: 1;
            text-align: center;
            padding: 0.5rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            cursor: pointer;
        }

        .time-option.selected {
            border-color: var(--focus);
            background: rgba(125, 211, 252, 0.1);
        }

        .subtask-selection {
            margin-top: 1rem;
        }

        .subtask-option {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            cursor: pointer;
        }

        .subtask-option.selected {
            border-color: var(--focus);
            background: rgba(125, 211, 252, 0.1);
        }

        .subtask-complete-prompt {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            text-align: center;
            display: none;
        }

        .subtask-complete-prompt.show {
            display: block;
        }

        .subtask-complete-options {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
        }

        .animation-type-selector {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
            justify-content: center;
        }

        .animation-option {
            padding: 0.5rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.5rem;
            cursor: pointer;
        }

        .animation-option.selected {
            border-color: var(--focus);
            background: rgba(125, 211, 252, 0.1);
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .task-list li {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .task-buttons {
                width: 100%;
                margin-top: 1rem;
                justify-content: space-between;
            }
            
            .stats {
                flex-direction: column;
                gap: 0.5rem;
            }

            .time-selector {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="celebration">
        <div class="reward-notification"></div>
    </div>
    
    <div class="bonus-card">
        <h2>Bonus Challenge!</h2>
        <p>Choose your reward path:</p>
        <div class="bonus-card-options">
            <div class="bonus-option" onclick="selectBonusOption('safe')">
                <h3>Safe</h3>
                <p>Guaranteed <span id="safeAmount">20</span> credits</p>
            </div>
            <div class="bonus-option" onclick="selectBonusOption('risky')">
                <h3>Risky</h3>
                <p>50% chance of <span id="riskyAmount">40</span> credits</p>
            </div>
            <div class="bonus-option" onclick="selectBonusOption('epic')">
                <h3>Epic</h3>
                <p>20% chance of <span id="epicAmount">100</span> credits</p>
            </div>
        </div>
    </div>
    
    <div class="pomodoro-modal" id="pomodoroModal">
        <div class="pomodoro-container">
            <h2 id="pomodoroTaskName">Task Name</h2>
            
            <!-- Pomodoro Setup -->
            <div id="pomodoroSetup" class="pomodoro-setup">
                <h3>Choose a Subtask</h3>
                <div id="subtaskSelection" class="subtask-selection">
                    <!-- Subtask options will be inserted here -->
                    <div class="subtask-option" onclick="selectSubtask('new')">+ Create New Subtask</div>
                </div>
                
                <div id="newSubtaskForm" style="display: none; margin-top: 1rem;">
                    <input type="text" id="newSubtaskInput" placeholder="Enter subtask description">
                    <button onclick="createSubtask()">Create</button>
                </div>
                
                <h3>Focus Duration</h3>
                <div class="time-selector">
                    <div class="time-option" data-value="15" onclick="selectFocusTime(15)">15 min</div>
                    <div class="time-option selected" data-value="25" onclick="selectFocusTime(25)">25 min</div>
                    <div class="time-option" data-value="45" onclick="selectFocusTime(45)">45 min</div>
                </div>
                
                <h3>Break Duration</h3>
                <div class="time-selector">
                    <div class="time-option" data-value="3" onclick="selectBreakTime(3)">3 min</div>
                    <div class="time-option selected" data-value="5" onclick="selectBreakTime(5)">5 min</div>
                    <div class="time-option" data-value="10" onclick="selectBreakTime(10)">10 min</div>
                </div>
                
                <h3>Animation Style</h3>
                <div class="animation-type-selector">
                    <div class="animation-option selected" data-type="forge" onclick="selectAnimationType('forge')">Forge ‚öíÔ∏è</div>
                    <div class="animation-option" data-type="magic" onclick="selectAnimationType('magic')">Magic ‚ú®</div>
                    <div class="animation-option" data-type="combat" onclick="selectAnimationType('combat')">Combat ‚öîÔ∏è</div>
                </div>
                
                <div style="margin-top: 1rem; text-align: center;">
                    <button onclick="startFocusSession()">Start Session</button>
                    <button onclick="closePomodoroModal()" style="background: #9ca3af;">Cancel</button>
                </div>
            </div>
            
            <!-- Timer Display (initially hidden) -->
            <div id="pomodoroTimer" style="display: none;">
                <div class="phase-indicator">
                    <span id="phaseType" class="focus-time">Focus Time</span>
                </div>
                <div class="timer-display" id="timerDisplay">25:00</div>
                
                <div class="pomodoro-animation">
                    <div class="pixel-scene" id="animationScene">
                        <!-- Animation elements will be added dynamically -->
                    </div>
                </div>
                
                <div class="timer-controls">
                    <button id="startTimer" onclick="startPomodoroTimer()">Start</button>
                    <button id="pauseTimer" onclick="pausePomodoroTimer()" disabled>Pause</button>
                    <button id="skipTimer" onclick="skipPomodoroPhase()">Skip</button>
                    <button onclick="abandonPomodoroSession()">Exit</button>
                </div>
                
                <div class="pomodoro-progress" id="pomodoroProgress">
                    <!-- Pomodoro segments will be added here -->
                </div>
                
                <div class="pomodoro-stats">
                    <h3>Session Stats</h3>
                    <p><strong>Working on:</strong> <span id="currentSubtask">Subtask name</span></p>
                    <p>Sessions completed: <span id="completedPomodoros">0</span></p>
                    <p>Efficiency bonus: +<span id="efficiencyBonus">0</span>% chance of bonus rewards</p>
                </div>
            </div>
            
            <!-- Subtask Completion Prompt (hidden until needed) -->
            <div id="subtaskCompletePrompt" class="subtask-complete-prompt">
                <h3>Time's up!</h3>
                <p>Did you complete the subtask: <strong id="completionSubtaskName">Subtask name</strong>?</p>
                <div class="subtask-complete-options">
                    <button onclick="handleSubtaskComplete(true)" style="background: var(--success);">Yes, completed!</button>
                    <button onclick="handleSubtaskComplete(false)" style="background: var(--primary);">Not yet, continue</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="header">
            <h1>Quest Todo</h1>
            <div class="stats">
                <div class="level-container">
                    <div class="level">Level <span id="playerLevel">1</span></div>
                    <div style="margin-left: 0.5rem;">
                        <div class="level-bar">
                            <div class="level-bar-fill" id="levelProgress" style="width: 0%"></div>
                        </div>
                        <div style="font-size: 0.75rem; text-align: center;"><span id="currentXP">0</span>/<span id="xpToNextLevel">100</span> XP</div>
                    </div>
                </div>
                <div class="streak">Streak: <span id="currentStreak">0</span> days</div>
                <div class="credits">Credits: <span id="totalCredits">0</span></div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>Add Quest</h2>
                <form id="taskForm">
                    <input type="text" id="taskName" placeholder="Quest name" required>
                    <input type="number" id="timeEstimate" placeholder="Time estimate (hours)" required min="0" step="0.5">
                    <select id="importance" required>
                        <option value="">Select difficulty</option>
                        <option value="1">Easy ‚òÖ</option>
                        <option value="2">Normal ‚òÖ‚òÖ</option>
                        <option value="3">Hard ‚òÖ‚òÖ‚òÖ</option>
                        <option value="4">Very Hard ‚òÖ‚òÖ‚òÖ‚òÖ</option>
                        <option value="5">Epic ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</option>
                    </select>
                    <input type="date" id="deadline" required>
                    <button type="submit">Create Quest</button>
                </form>
                
                <div class="dice-roll" id="diceRollDisplay">
                    <!-- Dice will be injected here when rolling -->
                </div>
                
                <div style="margin-top: 1rem;">
                    <h3>Loot Table</h3>
                    <div class="loot-table">
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: #9ca3af;"></div>
                            Common (60%)
                        </div>
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: var(--success);"></div>
                            Uncommon (25%)
                        </div>
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: var(--rare);"></div>
                            Rare (10%)
                        </div>
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: var(--epic);"></div>
                            Epic (4%)
                        </div>
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: var(--legendary);"></div>
                            Legendary (1%)
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>Add Reward</h2>
                <form id="wishlistForm">
                    <input type="text" id="itemName" placeholder="Reward name" required>
                    <input type="number" id="itemCost" placeholder="Cost (HKD)" required min="0">
                    <input type="number" id="timeline" placeholder="Timeline (weeks)" required min="1">
                    <select id="desireLevel" required>
                        <option value="">How much do you want this?</option>
                        <option value="1">Nice to have</option>
                        <option value="2">Want it</option>
                        <option value="3">Really want it</option>
                        <option value="4">Desperately want it</option>
                        <option value="5">Must have it!</option>
                    </select>
                    <button type="submit">Add Reward</button>
                </form>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>Active Quests</h2>
                <ul id="taskList" class="task-list"></ul>
            </div>

            <div class="card">
                <h2>Rewards</h2>
                <ul id="wishlist" class="wishlist"></ul>
            </div>
        </div>
    </div>

    <script>
        // State management
        let state = {
            tasks: [],
            wishlist: [],
            credits: 0,
            streak: 0,
            lastStreak: new Date().toDateString(),
            notifications: [],
            milestones: {},
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            lastDaily: null,
            bonusChallenge: null,
            completionHistory: [],
            activePomodoro: null
        };
        
        // Advanced icon mapping based on context, categories and natural language
        const iconMappings = {
            // Work and Education
            "work": ["üíº", "üè¢", "üìä", "üìà", "üìâ", "üóÇÔ∏è"],
            "office": ["üíº", "üè¢", "üñ•Ô∏è", "üìû", "üì†", "üìé"],
            "job": ["üíº", "üëî", "üßë‚Äçüíº", "üë©‚Äçüíº", "üë®‚Äçüíº"],
            "business": ["üíº", "üìä", "üìà", "üìâ", "üè¢", "üí∞"],
            "email": ["üìß", "üì®", "üì©", "üíå"],
            "meeting": ["üë•", "üó£Ô∏è", "üëî", "üìÖ", "‚è∞"],
            "presentation": ["üìä", "üìà", "üìâ", "üé§", "üé≠"],
            "report": ["üìë", "üìù", "üìã", "üìä", "üñäÔ∏è"],
            "project": ["üèóÔ∏è", "üìã", "üìä", "‚öôÔ∏è", "üîß", "üìù"],
            "deadline": ["‚è∞", "‚è±Ô∏è", "üìÖ", "üìÜ", "üóìÔ∏è"],
            
            "study": ["üìö", "üß†", "üéì", "üìù", "üìñ"],
            "learn": ["üìö", "üß†", "üéì", "üìù", "üìñ"],
            "school": ["üè´", "üìö", "üéí", "‚úèÔ∏è", "üìù"],
            "college": ["üéì", "üè´", "üìö", "üìù", "üß†"],
            "university": ["üéì", "üè´", "üìö", "üìù", "üß†"],
            "class": ["üìö", "üéì", "üè´", "üë®‚Äçüè´", "üë©‚Äçüè´"],
            "course": ["üìö", "üéì", "üè´", "üë®‚Äçüéì", "üë©‚Äçüéì"],
            "lecture": ["üéì", "üìö", "üè´", "üë®‚Äçüè´", "üë©‚Äçüè´"],
            "homework": ["üìö", "üìù", "‚úèÔ∏è", "üìì", "üìî"],
            "assignment": ["üìù", "üìö", "‚úèÔ∏è", "üìã", "üìé"],
            "essay": ["üìù", "‚úèÔ∏è", "üìÑ", "üìÉ", "üñäÔ∏è"],
            "exam": ["üìù", "‚úçÔ∏è", "üìÑ", "üìë", "üß†"],
            "test": ["üìù", "‚úçÔ∏è", "üìÑ", "üìë", "üß†"],
            "quiz": ["‚ùì", "‚ùî", "üß†", "üìù", "‚úçÔ∏è"],
            "research": ["üî¨", "üîç", "üìö", "üß†", "üìä"],
            "paper": ["üìÑ", "üìÉ", "üìù", "‚úçÔ∏è", "üñäÔ∏è"],
            "thesis": ["üìö", "üìù", "üéì", "üß†", "üìë"],
            
            // Technology and Programming
            "code": ["üíª", "üë®‚Äçüíª", "üë©‚Äçüíª", "‚å®Ô∏è", "üñ•Ô∏è", "üíæ"],
            "program": ["üíª", "üë®‚Äçüíª", "üë©‚Äçüíª", "‚å®Ô∏è", "üñ•Ô∏è", "üíæ"],
            "programming": ["üíª", "üë®‚Äçüíª", "üë©‚Äçüíª", "‚å®Ô∏è", "üñ•Ô∏è", "üíæ"],
            "coding": ["üíª", "üë®‚Äçüíª", "üë©‚Äçüíª", "‚å®Ô∏è", "üñ•Ô∏è", "üíæ"],
            "develop": ["üíª", "üë®‚Äçüíª", "üë©‚Äçüíª", "‚å®Ô∏è", "üñ•Ô∏è", "üöÄ"],
            "software": ["üíª", "üñ•Ô∏è", "üíø", "üì±", "‚öôÔ∏è"],
            "app": ["üì±", "üíª", "üñ•Ô∏è", "üì≤", "üöÄ"],
            "website": ["üåê", "üíª", "üñ•Ô∏è", "üñ±Ô∏è", "üîó"],
            "database": ["üíæ", "üóÉÔ∏è", "üìä", "üî¢", "üîç"],
            "debug": ["üêû", "üîç", "üíª", "üîß", "‚öôÔ∏è"],
            "fix": ["üîß", "‚öôÔ∏è", "üß∞", "üî®", "üíª"],
            "computer": ["üñ•Ô∏è", "üíª", "‚å®Ô∏è", "üñ±Ô∏è", "üîå"],
            "laptop": ["üíª", "‚å®Ô∏è", "üîå", "üì±", "üñ•Ô∏è"],
            "tech": ["üíª", "üñ•Ô∏è", "üì±", "‚öôÔ∏è", "üîß"],
            
            // Health and Fitness
            "health": ["‚ù§Ô∏è", "ü©∫", "üíâ", "üíä", "üè•"],
            "doctor": ["üë®‚Äç‚öïÔ∏è", "üë©‚Äç‚öïÔ∏è", "ü©∫", "üè•", "üíâ"],
            "medical": ["ü©∫", "üíâ", "üíä", "üè•", "üë®‚Äç‚öïÔ∏è"],
            "hospital": ["üè•", "üë®‚Äç‚öïÔ∏è", "üë©‚Äç‚öïÔ∏è", "ü©∫", "üíâ"],
            "medication": ["üíä", "üíâ", "üë®‚Äç‚öïÔ∏è", "üë©‚Äç‚öïÔ∏è", "ü©∫"],
            "appointment": ["üìÖ", "‚è∞", "üë®‚Äç‚öïÔ∏è", "üë©‚Äç‚öïÔ∏è", "ü©∫"],
            "checkup": ["ü©∫", "üë®‚Äç‚öïÔ∏è", "üë©‚Äç‚öïÔ∏è", "‚ù§Ô∏è", "üè•"],
            
            "workout": ["üí™", "üèãÔ∏è", "üèÉ", "üßò", "ü§∏"],
            "exercise": ["üèÉ", "üí™", "üèãÔ∏è", "üßò", "üö¥"],
            "gym": ["üèãÔ∏è", "üí™", "üèÉ", "ü§∏", "‚öñÔ∏è"],
            "fitness": ["üí™", "üèãÔ∏è", "üèÉ", "üßò", "‚öñÔ∏è"],
            "run": ["üèÉ", "üëü", "üéΩ", "‚è±Ô∏è", "üèÜ"],
            "jog": ["üèÉ", "üëü", "üéΩ", "‚è±Ô∏è", "üå≥"],
            "yoga": ["üßò", "üßò‚Äç‚ôÄÔ∏è", "üßò‚Äç‚ôÇÔ∏è", "üèä", "üíÜ"],
            "swim": ["üèä", "üèä‚Äç‚ôÄÔ∏è", "üèä‚Äç‚ôÇÔ∏è", "ü©≤", "üåä"],
            "bike": ["üö¥", "üö¥‚Äç‚ôÄÔ∏è", "üö¥‚Äç‚ôÇÔ∏è", "üö≤", "üèÜ"],
            "weight": ["‚öñÔ∏è", "üèãÔ∏è", "üí™", "ü•ó", "üçé"],
            "diet": ["ü•ó", "üçé", "ü•¶", "‚öñÔ∏è", "üí™"],
            "nutrition": ["ü•ó", "üçé", "ü•¶", "‚öñÔ∏è", "üí™"],
            "meal": ["üçΩÔ∏è", "üç≤", "ü•ó", "üçõ", "üç±"],
            "cook": ["üç≥", "üë®‚Äçüç≥", "üë©‚Äçüç≥", "üî™", "üç≤"],
            "recipe": ["üìù", "üç≤", "üç≥", "üçΩÔ∏è", "üë®‚Äçüç≥"],
            "food": ["üçΩÔ∏è", "üç≤", "ü•ó", "üçõ", "üç±"],
            
            "sleep": ["üò¥", "üí§", "üõå", "üåô", "üõèÔ∏è"],
            "rest": ["üò¥", "üí§", "üõå", "üåô", "üõèÔ∏è"],
            "meditate": ["üßò", "üßò‚Äç‚ôÄÔ∏è", "üßò‚Äç‚ôÇÔ∏è", "üíÜ", "üí≠"],
            "meditation": ["üßò", "üßò‚Äç‚ôÄÔ∏è", "üßò‚Äç‚ôÇÔ∏è", "üíÜ", "üí≠"],
            "relax": ["üíÜ", "üßò", "üõå", "üçµ", "üìñ"],
            
            // Home and Daily Life
            "home": ["üè†", "üè°", "üèòÔ∏è", "üõãÔ∏è", "üõå"],
            "house": ["üè†", "üè°", "üèòÔ∏è", "üõãÔ∏è", "üõå"],
            "apartment": ["üè¢", "üèôÔ∏è", "üåÜ", "üõãÔ∏è", "üõå"],
            "clean": ["üßπ", "üßº", "üßΩ", "üß¥", "üóëÔ∏è"],
            "cleaning": ["üßπ", "üßº", "üßΩ", "üß¥", "üóëÔ∏è"],
            "laundry": ["üß∫", "üëï", "üëñ", "üßº", "üß¥"],
            "dishes": ["üçΩÔ∏è", "üßº", "üßΩ", "üç¥", "ü•Ñ"],
            "groceries": ["üõí", "üçé", "ü•¶", "ü•ï", "üõçÔ∏è"],
            "shopping": ["üõçÔ∏è", "üõí", "üëú", "üëï", "üëñ"],
            "organize": ["üìã", "üìÅ", "üóÑÔ∏è", "üìë", "üìé"],
            "pack": ["üì¶", "üß≥", "üéí", "üëú", "üëï"],
            "unpack": ["üì¶", "üß≥", "üéí", "üëú", "üëï"],
            "move": ["üöö", "üì¶", "üè†", "üè°", "üèòÔ∏è"],
            "repair": ["üîß", "‚öôÔ∏è", "üî®", "üß∞", "üõ†Ô∏è"],
            
            // Finances and Money
            "money": ["üí∞", "üíµ", "üí∏", "üí≤", "üíπ"],
            "finance": ["üí∞", "üíµ", "üí∏", "üíπ", "üìä"],
            "budget": ["üíπ", "üí∞", "üíµ", "üìä", "üìù"],
            "pay": ["üíµ", "üí∏", "üí≥", "üí∞", "üßæ"],
            "bill": ["üí∞", "üíµ", "üßæ", "üìÉ", "üìù"],
            "tax": ["üìë", "üí∞", "üíµ", "üìù", "üìã"],
            "bank": ["üè¶", "üí∞", "üíµ", "üí≥", "üíπ"],
            "invest": ["üìà", "üíπ", "üí∞", "üìä", "üíµ"],
            "investment": ["üìà", "üíπ", "üí∞", "üìä", "üíµ"],
            "save": ["üí∞", "üíπ", "üè¶", "üíµ", "üí≤"],
            "expense": ["üí∏", "üí∞", "üíµ", "üìù", "üßæ"],
            
            // Social and Relationships
            "call": ["üìû", "üì±", "‚òéÔ∏è", "üë•", "üí¨"],
            "phone": ["üì±", "üìû", "‚òéÔ∏è", "üë•", "üí¨"],
            "text": ["üí¨", "üì±", "üìû", "üë•", "üíå"],
            "message": ["üí¨", "üì±", "üìû", "üë•", "üíå"],
            "chat": ["üí¨", "üë•", "üó£Ô∏è", "üì±", "üíå"],
            "social": ["üë•", "üë®‚Äçüë©‚Äçüëß‚Äçüë¶", "üí¨", "üë™", "üë´"],
            "friend": ["üë´", "üë≠", "üë¨", "üë•", "üí¨"],
            "family": ["üë™", "üë®‚Äçüë©‚Äçüëß‚Äçüë¶", "üë®‚Äçüë©‚Äçüëß", "üë®‚Äçüë©‚Äçüë¶", "‚ù§Ô∏è"],
            "party": ["üéâ", "üéä", "üéà", "üéÇ", "ü•≥"],
            "date": ["‚ù§Ô∏è", "üíï", "üíë", "üë´", "üåπ"],
            "gift": ["üéÅ", "üéÄ", "üíù", "üéä", "üéâ"],
            "birthday": ["üéÇ", "üéÅ", "üéä", "üéâ", "üéà"],
            "wedding": ["üíí", "üíç", "üë∞", "ü§µ", "üíê"],
            "anniversary": ["üíç", "‚ù§Ô∏è", "üíë", "üíê", "üéâ"],
            
            // Travel and Transportation
            "travel": ["‚úàÔ∏è", "üß≥", "üó∫Ô∏è", "üèñÔ∏è", "üèùÔ∏è"],
            "trip": ["üß≥", "‚úàÔ∏è", "üó∫Ô∏è", "üèñÔ∏è", "üöó"],
            "vacation": ["üèñÔ∏è", "üèùÔ∏è", "üß≥", "‚úàÔ∏è", "‚õ±Ô∏è"],
            "flight": ["‚úàÔ∏è", "üõ´", "üõ¨", "üß≥", "üîç"],
            "airport": ["‚úàÔ∏è", "üõ´", "üõ¨", "üß≥", "üè¢"],
            "hotel": ["üè®", "üõå", "üß≥", "üöø", "üõéÔ∏è"],
            "drive": ["üöó", "üöò", "üöô", "üõ£Ô∏è", "üö¶"],
            "car": ["üöó", "üöò", "üöô", "üõ£Ô∏è", "üö¶"],
            "bus": ["üöå", "üöè", "üöç", "üöé", "üöê"],
            "train": ["üöÇ", "üöÜ", "üöÑ", "üöÖ", "üöâ"],
            "bike": ["üö≤", "üö¥", "üöµ", "üö¥‚Äç‚ôÄÔ∏è", "üö¥‚Äç‚ôÇÔ∏è"],
            
            // Entertainment and Leisure
            "game": ["üéÆ", "üé≤", "üéØ", "üé™", "üé≠"],
            "gaming": ["üéÆ", "üé≤", "üéØ", "üé™", "üé≠"],
            "play": ["üéÆ", "üé≤", "üéØ", "üé™", "üé≠"],
            "movie": ["üé¨", "üçø", "üéûÔ∏è", "üé¶", "üé•"],
            "film": ["üé¨", "üçø", "üéûÔ∏è", "üé¶", "üé•"],
            "tv": ["üì∫", "üé¨", "üçø", "üì°", "üé¶"],
            "show": ["üì∫", "üé¨", "üé≠", "üé™", "üé¶"],
            "theater": ["üé≠", "üé¨", "üé™", "üéüÔ∏è", "üé¶"],
            "concert": ["üéµ", "üé∏", "üé§", "üé∑", "üé∫"],
            "music": ["üéµ", "üé∏", "üé§", "üé∑", "üé∫"],
            "instrument": ["üé∏", "üéπ", "üéª", "üé∑", "üé∫"],
            "album": ["üíø", "üìÄ", "üéµ", "üé∂", "üéß"],
            "podcast": ["üéß", "üé§", "üéôÔ∏è", "üì±", "üéµ"],
            "book": ["üìö", "üìñ", "üìï", "üìó", "üìò"],
            "read": ["üìñ", "üìö", "üìï", "üìó", "üìò"],
            "novel": ["üìï", "üìñ", "üìö", "üìó", "üìò"],
            "art": ["üé®", "üñºÔ∏è", "üñåÔ∏è", "üé≠", "üé™"],
            "draw": ["‚úèÔ∏è", "üñåÔ∏è", "üé®", "üñçÔ∏è", "üñäÔ∏è"],
            "paint": ["üé®", "üñåÔ∏è", "üñºÔ∏è", "üñçÔ∏è", "‚úèÔ∏è"],
            "craft": ["üß∂", "üßµ", "üß∏", "üé®", "‚úÇÔ∏è"],
            "hobby": ["üé®", "üì∑", "üéÆ", "üé≠", "üéØ"],
            
            // Reward related items
            "clothes": ["üëï", "üëñ", "üëó", "üëö", "üëî"],
            "shoes": ["üëü", "üëû", "üë†", "üë°", "üë¢"],
            "watch": ["‚åö", "‚è±Ô∏è", "‚è∞", "üï∞Ô∏è", "‚è≤Ô∏è"],
            "jewelry": ["üíç", "üíé", "üëë", "üëí", "üìø"],
            "accessory": ["üëì", "üï∂Ô∏è", "üëú", "üëù", "üìø"],
            "gadget": ["üîå", "üì±", "‚åö", "üì∑", "üñ•Ô∏è"],
            "phone": ["üì±", "üì≤", "‚òéÔ∏è", "üìû", "üì≥"],
            "laptop": ["üíª", "‚å®Ô∏è", "üñ±Ô∏è", "üîå", "üñ•Ô∏è"],
            "computer": ["üñ•Ô∏è", "‚å®Ô∏è", "üñ±Ô∏è", "üîå", "üíª"],
            "camera": ["üì∑", "üì∏", "üìπ", "üé•", "üìΩÔ∏è"],
            "headphone": ["üéß", "üéµ", "üé∂", "üé∏", "üé∑"],
            "speaker": ["üîä", "üì¢", "üéµ", "üé∂", "üé§"],
            "console": ["üéÆ", "üïπÔ∏è", "üì∫", "üé≤", "üéØ"],
            "toy": ["üß∏", "ü™Ä", "ü™Å", "üé≤", "üéØ"],
            "book": ["üìö", "üìñ", "üìï", "üìó", "üìò"],
            "subscription": ["üì±", "üíª", "üì∫", "üéµ", "üìö"],
            "membership": ["üîë", "ü™™", "üí≥", "üèÜ", "üéñÔ∏è"],
            "ticket": ["üé´", "üéüÔ∏è", "üé≠", "üé™", "üé¨"],
            "restaurant": ["üçΩÔ∏è", "üç¥", "ü•£", "üçõ", "üç±"],
            "dinner": ["üçΩÔ∏è", "üç¥", "ü•ò", "üçõ", "üç±"],
            "lunch": ["üçΩÔ∏è", "üç¥", "ü•™", "üç±", "ü•ó"],
            "coffee": ["‚òï", "üßã", "ü•§", "üçµ", "ü´ñ"],
            "drink": ["üçπ", "üç∏", "ü•§", "üßÉ", "üç∑"],
            "spa": ["üíÜ", "üíÜ‚Äç‚ôÄÔ∏è", "üíÜ‚Äç‚ôÇÔ∏è", "üßñ", "üßñ‚Äç‚ôÄÔ∏è"],
            "massage": ["üíÜ", "üíÜ‚Äç‚ôÄÔ∏è", "üíÜ‚Äç‚ôÇÔ∏è", "üßñ", "üßñ‚Äç‚ôÄÔ∏è"],
            "donation": ["‚ù§Ô∏è", "üß°", "üíõ", "üíö", "üíô"],
            "charity": ["‚ù§Ô∏è", "üß°", "üíõ", "üíö", "üíô"],
            "savings": ["üí∞", "üíµ", "üí∏", "üí≤", "üíπ"],
            "investment": ["üìà", "üíπ", "üí∞", "üíµ", "üí≤"]
        };
        
        // Additional categories for icon detection
        const categoryPatterns = [
            {category: "food", patterns: ["eat", "meal", "food", "cook", "lunch", "dinner", "breakfast", "restaurant", "menu", "diet", "nutrition"], icons: ["üçΩÔ∏è", "üç¥", "ü•ò", "üç≤", "ü•ó", "üç±", "üçõ", "üçú", "üçù", "üçï", "üçî", "üåÆ", "üåØ", "üç£", "üç§", "üç¶", "üç∞"]},
            {category: "creative", patterns: ["create", "design", "art", "write", "draw", "paint", "craft", "build", "make", "develop"], icons: ["üé®", "‚úèÔ∏è", "üñåÔ∏è", "üìù", "‚úçÔ∏è", "üß∂", "üßµ", "üñºÔ∏è", "üìê", "üìè", "üî®"]},
            {category: "productivity", patterns: ["task", "goal", "plan", "organize", "schedule", "track", "manage", "achieve", "focus", "habit"], icons: ["üìã", "‚úÖ", "üìù", "‚è∞", "üìä", "üìà", "üìâ", "üìÖ", "üóìÔ∏è", "üîç", "üìí"]},
            {category: "communication", patterns: ["talk", "speak", "discuss", "message", "call", "chat", "contact", "email", "meeting", "interview"], icons: ["üí¨", "üìû", "üì±", "üìß", "üó£Ô∏è", "üë•", "ü§ù", "üì¢", "üì£", "üì®"]},
            {category: "digital", patterns: ["online", "digital", "internet", "web", "app", "site", "device", "tech", "computer", "software", "hardware"], icons: ["üíª", "üñ•Ô∏è", "üì±", "üåê", "üì±", "‚å®Ô∏è", "üñ±Ô∏è", "üíæ", "üì≤", "üîå"]},
            {category: "wellness", patterns: ["health", "wellbeing", "wellness", "self-care", "mindful", "mental", "balance", "therapy", "calm", "peace"], icons: ["üßò", "üíÜ", "üß†", "‚ù§Ô∏è", "üå±", "üîÜ", "üí´", "üíß", "üåø", "üçÉ", "üåà"]},
            {category: "adventure", patterns: ["explore", "adventure", "discover", "travel", "journey", "trip", "experience", "visit", "tour", "hike"], icons: ["üó∫Ô∏è", "üß≠", "üèîÔ∏è", "üèùÔ∏è", "üèñÔ∏è", "üåã", "üèûÔ∏è", "üöµ", "üßó", "‚õ∞Ô∏è", "üåÑ"]},
            {category: "learning", patterns: ["learn", "study", "education", "course", "skill", "knowledge", "practice", "train", "master", "improve"], icons: ["üìö", "üß†", "üéì", "üìù", "üìñ", "üîç", "üß©", "üìä", "üìà", "üî¨", "üìì"]},
            {category: "finance", patterns: ["money", "finance", "saving", "budget", "invest", "earn", "spend", "cost", "price", "purchase", "buy"], icons: ["üí∞", "üíµ", "üí≥", "üí≤", "üíπ", "üìä", "üìà", "üìâ", "üè¶", "üí∏", "üßæ"]},
            {category: "gaming", patterns: ["game", "play", "gaming", "level", "score", "achievement", "quest", "mission", "challenge", "reward"], icons: ["üéÆ", "üé≤", "üéØ", "üé™", "üé≠", "üé®", "üé™", "üéØ", "üé™", "üé≠", "üéØ"]},
            {category: "relationship", patterns: ["friend", "family", "relationship", "partner", "date", "love", "social", "connect", "bond", "together"], icons: ["‚ù§Ô∏è", "üë™", "üë´", "üë¨", "üë≠", "üíë", "üë®‚Äçüë©‚Äçüëß‚Äçüë¶", "ü§ù", "ü´Ç", "üíñ", "üíû"]},
            {category: "home", patterns: ["home", "house", "apartment", "room", "decor", "furniture", "clean", "organize", "arrange", "maintain"], icons: ["üè†", "üè°", "üßπ", "üõãÔ∏è", "üõèÔ∏è", "ü™ë", "üö™", "üß∫", "üßº", "ü™¥", "ü™ü"]},
        ];
        
        // Determine icons for a given text using advanced natural language analysis
        function determineIcon(text) {
            if (!text) return "üìù"; // Default fallback
            
            const lowerText = text.toLowerCase();
            const words = lowerText.split(/\s+|,|\.|\(|\)|\[|\]|\/|-|_/);
            
            // First, try to find direct keyword matches
            for (const word of words) {
                if (word.length > 2 && iconMappings[word]) {
                    // If we have a direct match, randomly select from available options
                    const icons = iconMappings[word];
                    return icons[Math.floor(Math.random() * icons.length)];
                }
            }
            
            // Next, try partial matches (words containing our keywords)
            for (const [keyword, icons] of Object.entries(iconMappings)) {
                if (keyword.length > 3 && lowerText.includes(keyword)) {
                    return icons[Math.floor(Math.random() * icons.length)];
                }
            }
            
            // Try to detect category based on patterns
            for (const category of categoryPatterns) {
                for (const pattern of category.patterns) {
                    if (lowerText.includes(pattern)) {
                        return category.icons[Math.floor(Math.random() * category.icons.length)];
                    }
                }
            }
            
            // Use semantic analysis based on word length and word count
            // (This creates a deterministic but less obvious pattern than just length % 5)
            const totalWordLength = words.reduce((sum, word) => sum + word.length, 0);
            const wordCount = words.length;
            
            // Use a combination of factors to create variety
            const iconIndex = (totalWordLength * 3 + wordCount * 7) % 25;
            
            // Emoji clusters based on general themes
            const generalIcons = [
                "üìù", "‚úÖ", "üéØ", "üîç", "üìä", // Productivity & Goals
                "üß©", "üé≤", "üéÆ", "üèÜ", "üéØ", // Games & Challenges
                "‚ö°", "‚ú®", "üí´", "üåü", "‚≠ê", // Energy & Inspiration
                "üì¶", "üõ†Ô∏è", "üîß", "‚öôÔ∏è", "üß∞", // Tools & Building
                "üîÆ", "üåà", "ü™Ñ", "üßø", "üé≠"  // Magic & Creative
            ];
            
            return generalIcons[iconIndex];
        }

        // Load state from localStorage
        function loadState() {
            const savedState = localStorage.getItem('questTodoState');
            if (savedState) {
                state = JSON.parse(savedState);
                
                // Backward compatibility
                if (!state.level) state.level = 1;
                if (!state.xp) state.xp = 0;
                if (!state.xpToNextLevel) state.xpToNextLevel = 100;
                if (!state.completionHistory) state.completionHistory = [];
                if (!state.activePomodoro) state.activePomodoro = null;
                
                // Backward compatibility for icons and stats
                state.tasks.forEach(task => {
                    if (!task.icon) {
                        task.icon = determineIcon(task.name);
                    }
                    if (!task.subtasks) {
                        task.subtasks = [];
                    }
                    if (!task.pomodoroStats) {
                        task.pomodoroStats = {
                            completedSessions: 0,
                            lootBonusPercent: 0
                        };
                    }
                });
                
                state.wishlist.forEach(item => {
                    if (!item.icon) {
                        item.icon = determineIcon(item.name);
                    }
                });
                
                // Check if streak should continue or reset
                const today = new Date().toDateString();
                const lastStreakDate = new Date(state.lastStreak);
                const dayDiff = Math.floor((new Date() - lastStreakDate) / (1000 * 60 * 60 * 24));
                
                if (dayDiff > 1) {
                    // Reset streak if more than a day has passed
                    state.streak = 0;
                }
                
                // Check for active pomodoro session
                if (state.activePomodoro) {
                    // Resume active session or clean up if too much time has passed
                    const now = new Date().getTime();
                    const timeSinceLastActivity = now - state.activePomodoro.lastActive;
                    
                    if (timeSinceLastActivity > 30 * 60 * 1000) { // 30 minutes
                        // Too much time has passed, clean up
                        state.activePomodoro = null;
                    }
                }
                
                // Check for daily bonus challenge
                checkDailyChallenge();
                
                updateUI();
            }
        }

        // Save state to localStorage
        function saveState() {
            localStorage.setItem('questTodoState', JSON.stringify(state));
        }

        // Check for daily bonus challenge
        function checkDailyChallenge() {
            const today = new Date().toDateString();
            if (state.lastDaily !== today) {
                // 30% chance of bonus challenge
                if (Math.random() < 0.3) {
                    // Create bonus challenge
                    const baseAmount = 20 + (state.level * 5);
                    state.bonusChallenge = {
                        safeAmount: baseAmount,
                        riskyAmount: Math.round(baseAmount * 2),
                        epicAmount: Math.round(baseAmount * 5),
                        day: today
                    };
                    
                    // Update the UI with the amounts
                    document.getElementById('safeAmount').textContent = state.bonusChallenge.safeAmount;
                    document.getElementById('riskyAmount').textContent = state.bonusChallenge.riskyAmount;
                    document.getElementById('epicAmount').textContent = state.bonusChallenge.epicAmount;
                    
                    // Show the bonus challenge
                    setTimeout(() => {
                        document.querySelector('.bonus-card').classList.add('show');
                    }, 1000);
                }
                state.lastDaily = today;
                saveState();
            }
        }
        
        // Select bonus option
        function selectBonusOption(option) {
            let amount = 0;
            let message = '';
            
            switch(option) {
                case 'safe':
                    amount = state.bonusChallenge.safeAmount;
                    message = `Safe choice! +${amount} credits`;
                    break;
                case 'risky':
                    if (Math.random() < 0.5) {
                        amount = state.bonusChallenge.riskyAmount;
                        message = `Risky paid off! +${amount} credits`;
                    } else {
                        message = 'Took a risk but no reward this time!';
                    }
                    break;
                case 'epic':
                    if (Math.random() < 0.2) {
                        amount = state.bonusChallenge.epicAmount;
                        message = `EPIC WIN! +${amount} credits`;
                    } else {
                        message = 'Went for epic... but no luck today!';
                    }
                    break;
            }
            
            if (amount > 0) {
                state.credits += amount;
                addXP(Math.round(amount / 2));
            }
            
            document.querySelector('.bonus-card').classList.remove('show');
            showNotification(message);
            
            state.bonusChallenge = null;
            saveState();
            updateUI();
        }
        
        // Add XP and handle leveling up
        function addXP(amount) {
            state.xp += amount;
            
            // Check for level up
            if (state.xp >= state.xpToNextLevel) {
                state.level++;
                // Carryover XP
                const carryover = state.xp - state.xpToNextLevel;
                // New XP threshold with increasing curve (harder to level up)
                state.xpToNextLevel = Math.round(state.xpToNextLevel * 1.5);
                state.xp = carryover;
                
                // Level up bonus
                const levelBonus = state.level * 25;
                state.credits += levelBonus;
                
                showNotification(`üéÆ LEVEL UP! You're now level ${state.level}! +${levelBonus} credits bonus!`);
            }
            
            saveState();
        }

        // Calculate task rarity based on importance, time and deadline proximity
        function calculateTaskRarity(importance, timeEstimate, deadline) {
            const daysRemaining = Math.max(0, (new Date(deadline) - new Date()) / (1000 * 60 * 60 * 24));
            const urgencyFactor = Math.max(1, 3 - (daysRemaining / 7)); // Higher urgency for closer deadlines
            
            // Task difficulty score (0-100)
            const difficultyScore = (importance * 15) + (timeEstimate * 5) + (urgencyFactor * 10);
            
            // Determine rarity
            if (difficultyScore >= 90) return 'legendary';
            if (difficultyScore >= 70) return 'epic';
            if (difficultyScore >= 50) return 'rare';
            if (difficultyScore >= 30) return 'uncommon';
            return 'common';
        }
        
        // Calculate credits for a task with rarity modifier
        function calculateCredits(importance, timeEstimate, deadline, rarity) {
            const daysRemaining = Math.max(0, (new Date(deadline) - new Date()) / (1000 * 60 * 60 * 24));
            const urgencyFactor = Math.max(1, 3 - (daysRemaining / 7)); // Higher urgency for closer deadlines
            
            // Base formula with some randomness for variable rewards
            const variability = 0.9 + (Math.random() * 0.2); // 90%-110% variability
            
            // Rarity multipliers
            const rarityMultipliers = {
                'common': 1,
                'uncommon': 1.5,
                'rare': 2,
                'epic': 3,
                'legendary': 5
            };
            
            // Base credits calculation
            let baseCredits = (importance * 5 + Math.log(timeEstimate + 1) * 3) * urgencyFactor * variability;
            
            // Apply rarity modifier
            baseCredits *= rarityMultipliers[rarity];
            
            // Apply anti-farming diminishing returns
            const recentCompletions = countRecentCompletions();
            if (recentCompletions > 5) {
                const diminishingFactor = Math.max(0.5, 1 - ((recentCompletions - 5) * 0.05));
                baseCredits *= diminishingFactor;
            }
            
            return Math.round(baseCredits);
        }
        
        // Count recent task completions (anti-farming)
        function countRecentCompletions() {
            const now = new Date();
            const oneDayAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
            
            return state.completionHistory.filter(timestamp => {
                return new Date(timestamp) > oneDayAgo;
            }).length;
        }

        // Roll dice for critical success chance
        function rollDice() {
            const diceContainer = document.getElementById('diceRollDisplay');
            diceContainer.innerHTML = '';
            diceContainer.classList.add('show');
            
            // Create and show dice
            const dice = document.createElement('div');
            dice.className = 'dice';
            diceContainer.appendChild(dice);
            
            // Animate dice roll
            setTimeout(() => {
                const roll = Math.floor(Math.random() * 20) + 1; // d20
                dice.textContent = roll;
                
                // Determine if critical success
                let criticalSuccess = false;
                
                // Base 5% chance (roll of 20)
                if (roll === 20) {
                    criticalSuccess = true;
                } 
                // Streak increases critical chance
                else if (roll >= (20 - Math.min(5, Math.floor(state.streak / 2)))) {
                    criticalSuccess = true;
                }
                
                dice.style.background = criticalSuccess ? 'var(--legendary)' : 'var(--primary)';
                
                return criticalSuccess;
            }, 750);
            
            // Hide dice after animation
            setTimeout(() => {
                diceContainer.classList.remove('show');
            }, 3000);
        }

        // Show celebration/notification
        function showNotification(message, type = 'success') {
            const notificationEl = document.querySelector('.reward-notification');
            notificationEl.textContent = message;
            notificationEl.style.backgroundColor = type === 'success' ? 'var(--success)' : 'var(--primary)';
            
            document.querySelector('.celebration').style.opacity = '1';
            notificationEl.style.opacity = '1';
            notificationEl.style.transform = 'translateY(0)';
            
            setTimeout(() => {
                notificationEl.style.opacity = '0';
                notificationEl.style.transform = 'translateY(20px)';
                document.querySelector('.celebration').style.opacity = '0';
            }, 3000);
        }

        // Add task
        document.getElementById('taskForm').addEventListener('submit', (e) => {
            e.preventDefault();
            
            const taskName = document.getElementById('taskName').value;
            const importance = parseInt(document.getElementById('importance').value);
            const timeEstimate = parseFloat(document.getElementById('timeEstimate').value);
            const deadline = document.getElementById('deadline').value;
            
            // Calculate task rarity
            const rarity = calculateTaskRarity(importance, timeEstimate, deadline);
            
            // Determine a suitable icon
            const icon = determineIcon(taskName);
            
            // Calculate recommended pomodoros based on time estimate
            const recommendedPomodoros = Math.max(1, Math.ceil(timeEstimate * 2)); // 2 pomodoros per hour
            
            const task = {
                name: taskName,
                timeEstimate: timeEstimate,
                importance: importance,
                deadline: deadline,
                completed: false,
                rarity: rarity,
                icon: icon,
                credits: calculateCredits(importance, timeEstimate, deadline, rarity),
                xp: Math.round(importance * 10 + timeEstimate * 5), // Base XP
                created: new Date().toISOString(),
                subtasks: [],
                pomodoroStats: {
                    completedSessions: 0,
                    sessionsUsed: 0,
                    lootBonusPercent: 0,
                    sessionHistory: []
                }
            };
            
            state.tasks.push(task);
            saveState();
            updateUI();
            e.target.reset();
            
            showNotification(`New ${rarity} quest added: ${task.name}!`, 'primary');
        });

        // Add wishlist item with psychology-based credit formula
        document.getElementById('wishlistForm').addEventListener('submit', (e) => {
            e.preventDefault();
            
            const itemName = document.getElementById('itemName').value;
            const cost = parseFloat(document.getElementById('itemCost').value);
            const timeline = parseInt(document.getElementById('timeline').value);
            const desireLevel = parseInt(document.getElementById('desireLevel').value);
            
            // Determine a suitable icon
            const icon = determineIcon(itemName);
            
            // Base multiplier with variability
            const baseMultiplier = 9 + Math.random() * 2;
            
            // Progressive difficulty
            const difficultyMultiplier = state.wishlist.length === 0 ? 
                                        0.8 : // First item easier
                                        1 + (state.wishlist.length * 0.05); // Gets progressively harder
            
            // Timeline factor (longer timeline = more credits)
            const timelineFactor = 1 + (timeline / 20);
            
            // Desire discount (higher desire = slightly fewer credits)
            const desireMultiplier = 1.2 - (desireLevel * 0.08);
            
            // Calculate final credits
            const totalCredits = Math.round(cost * baseMultiplier * difficultyMultiplier * 
                                timelineFactor * desireMultiplier);
            
            // Endowed progress (small head start)
            const headStart = Math.min(0.05 * totalCredits, 50);
            
            const item = {
                name: itemName,
                icon: icon,
                cost: cost,
                timeline: timeline,
                desireLevel: desireLevel,
                credits: totalCredits,
                progress: headStart,
                displayProgress: headStart / totalCredits,
                milestones: [0.25, 0.5, 0.75, 1], // Progress milestones at 25%, 50%, 75%, 100%
                created: new Date().toISOString()
            };
            
            // Apply the head start if user has enough credits
            if (state.credits >= headStart) {
                state.credits -= headStart;
                showNotification(`Got a head start on "${item.name}"!`, 'primary');
            } else {
                item.progress = state.credits;
                item.displayProgress = state.credits / totalCredits;
                state.credits = 0;
            }
            
            // Create a unique ID for this item
            item.id = Date.now().toString();
            
            // Initialize milestones tracking
            state.milestones[item.id] = [];
            
            state.wishlist.push(item);
            saveState();
            updateUI();
            e.target.reset();
            
            showNotification(`New reward added: ${item.name}`, 'primary');
        });
        
        // Open Pomodoro modal for a task
        function startPomodoro(index) {
            const task = state.tasks[index];
            
            // Update task name in the modal
            document.getElementById('pomodoroTaskName').textContent = task.name;
            
            // Show setup screen, hide timer screen
            document.getElementById('pomodoroSetup').style.display = 'block';
            document.getElementById('pomodoroTimer').style.display = 'none';
            document.getElementById('subtaskCompletePrompt').classList.remove('show');
            
            // Populate subtask selection
            populateSubtaskSelection(task);
            
            // Reset time selections to defaults
            document.querySelectorAll('.time-option').forEach(option => {
                option.classList.remove('selected');
                if ((option.dataset.value === '25' && option.parentElement.classList.contains('time-selector')) || 
                    (option.dataset.value === '5' && !option.parentElement.classList.contains('time-selector'))) {
                    option.classList.add('selected');
                }
            });
            
            // Reset animation selection
            document.querySelectorAll('.animation-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.type === 'forge') {
                    option.classList.add('selected');
                }
            });
            
            // Store task index in activePomodoro
            state.activePomodoro = {
                taskIndex: index,
                subtaskIndex: null,
                focusDuration: 25,
                breakDuration: 5,
                phase: 'setup',
                animationType: 'forge',
                sessionsForCompletion: 0
            };
            
            saveState();
            
            // Show the modal
            document.getElementById('pomodoroModal').classList.add('show');
        }
        
        // Populate subtask selection
        function populateSubtaskSelection(task) {
            const subtaskSelection = document.getElementById('subtaskSelection');
            // Keep the "Create New Subtask" option
            subtaskSelection.innerHTML = '<div class="subtask-option" onclick="selectSubtask(\'new\')">+ Create New Subtask</div>';
            
            // Add existing subtasks
            if (task.subtasks && task.subtasks.length > 0) {
                task.subtasks.forEach((subtask, index) => {
                    if (!subtask.completed) {
                        const subtaskOption = document.createElement('div');
                        subtaskOption.className = 'subtask-option';
                        subtaskOption.textContent = subtask.name;
                        subtaskOption.onclick = () => selectSubtask(index);
                        subtaskSelection.insertBefore(subtaskOption, subtaskSelection.firstChild);
                    }
                });
            }
            
            // Hide new subtask form
            document.getElementById('newSubtaskForm').style.display = 'none';
        }
        
        // Select a subtask for pomodoro
        function selectSubtask(index) {
            // Remove selection from all options
            document.querySelectorAll('.subtask-option').forEach(option => {
                option.classList.remove('selected');
            });
            
            if (index === 'new') {
                // Show new subtask form
                document.getElementById('newSubtaskForm').style.display = 'block';
                document.getElementById('newSubtaskInput').focus();
                
                // Mark the "Create New" option as selected
                document.querySelector('.subtask-option').classList.add('selected');
            } else {
                // Hide new subtask form
                document.getElementById('newSubtaskForm').style.display = 'none';
                
                // Update activePomodoro state
                state.activePomodoro.subtaskIndex = index;
                
                // Mark the selected subtask
                document.querySelectorAll('.subtask-option').forEach((option, i) => {
                    if (i === index + 1) { // +1 because the first option is "Create New"
                        option.classList.add('selected');
                    }
                });
            }
        }
        
        // Create a new subtask
        function createSubtask() {
            const subtaskInput = document.getElementById('newSubtaskInput');
            const subtaskName = subtaskInput.value.trim();
            
            if (subtaskName && state.activePomodoro) {
                const taskIndex = state.activePomodoro.taskIndex;
                const task = state.tasks[taskIndex];
                
                const newSubtask = {
                    name: subtaskName,
                    completed: false,
                    created: new Date().toISOString()
                };
                
                task.subtasks.push(newSubtask);
                
                // Set the new subtask as the active one
                state.activePomodoro.subtaskIndex = task.subtasks.length - 1;
                
                saveState();
                populateSubtaskSelection(task);
                
                // Select the newly created subtask
                document.querySelectorAll('.subtask-option').forEach((option, i) => {
                    if (i === 0) { // The new subtask will be the first one
                        option.classList.add('selected');
                    }
                });
                
                subtaskInput.value = '';
                document.getElementById('newSubtaskForm').style.display = 'none';
            }
        }
        
        // Select focus time
        function selectFocusTime(duration) {
            document.querySelectorAll('.time-selector:first-of-type .time-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.value == duration) {
                    option.classList.add('selected');
                }
            });
            
            state.activePomodoro.focusDuration = duration;
        }
        
        // Select break time
        function selectBreakTime(duration) {
            document.querySelectorAll('.time-selector:nth-of-type(2) .time-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.value == duration) {
                    option.classList.add('selected');
                }
            });
            
            state.activePomodoro.breakDuration = duration;
        }
        
        // Select animation type
        function selectAnimationType(type) {
            document.querySelectorAll('.animation-option').forEach(option => {
                option.classList.remove('selected');
                if (option.dataset.type === type) {
                    option.classList.add('selected');
                }
            });
            
            state.activePomodoro.animationType = type;
        }
        
        // Start the focus session
        function startFocusSession() {
            if (!state.activePomodoro || state.activePomodoro.subtaskIndex === null) {
                alert("Please select a subtask first!");
                return;
            }
            
            const taskIndex = state.activePomodoro.taskIndex;
            const subtaskIndex = state.activePomodoro.subtaskIndex;
            const task = state.tasks[taskIndex];
            const subtask = task.subtasks[subtaskIndex];
            
            // Hide setup, show timer
            document.getElementById('pomodoroSetup').style.display = 'none';
            document.getElementById('pomodoroTimer').style.display = 'block';
            
            // Set up timer display
            document.getElementById('phaseType').textContent = 'Focus Time';
            document.getElementById('phaseType').className = 'focus-time';
            document.getElementById('timerDisplay').textContent = `${state.activePomodoro.focusDuration}:00`;
            document.getElementById('currentSubtask').textContent = subtask.name;
            
            // Reset session stats in UI
            document.getElementById('completedPomodoros').textContent = '0';
            document.getElementById('efficiencyBonus').textContent = '0';
            
            // Create session info
            state.activePomodoro.phase = 'focus';
            state.activePomodoro.timeRemaining = state.activePomodoro.focusDuration * 60; // in seconds
            state.activePomodoro.running = false;
            state.activePomodoro.startTime = null;
            state.activePomodoro.lastActive = new Date().getTime();
            state.activePomodoro.sessionsCompleted = 0;
            
            // Set up animation based on selected type
            setupAnimation(state.activePomodoro.animationType);
            
            // Reset buttons
            document.getElementById('startTimer').disabled = false;
            document.getElementById('pauseTimer').disabled = true;
            
            saveState();
        }
        
        // Set up pixel animation based on type
        function setupAnimation(type) {
            const animationScene = document.getElementById('animationScene');
            animationScene.innerHTML = '';
            
            switch (type) {
                case 'forge':
                    // Create forge elements
                    const character = document.createElement('div');
                    character.className = 'character';
                    
                    const forge = document.createElement('div');
                    forge.className = 'forge';
                    
                    const anvil = document.createElement('div');
                    anvil.className = 'anvil';
                    
                    const hammer = document.createElement('div');
                    hammer.className = 'hammer';
                    
                    const sparks = document.createElement('div');
                    sparks.className = 'sparks';
                    
                    animationScene.appendChild(character);
                    animationScene.appendChild(forge);
                    animationScene.appendChild(anvil);
                    animationScene.appendChild(hammer);
                    animationScene.appendChild(sparks);
                    
                    // Add multiple sparks
                    for (let i = 0; i < 5; i++) {
                        const sparkClone = sparks.cloneNode();
                        sparkClone.style.animationDelay = `${i * 0.1}s`;
                        sparkClone.style.left = `${175 + Math.random() * 10}px`;
                        animationScene.appendChild(sparkClone);
                    }
                    break;
                    
                case 'magic':
                    // Create magic elements
                    const magicCharacter = document.createElement('div');
                    magicCharacter.className = 'character';
                    magicCharacter.style.background = '#818cf8';
                    
                    const magicCircle = document.createElement('div');
                    magicCircle.className = 'magic-circle';
                    
                    animationScene.appendChild(magicCharacter);
                    animationScene.appendChild(magicCircle);
                    
                    // Add multiple particles
                    for (let i = 0; i < 8; i++) {
                        const particle = document.createElement('div');
                        particle.className = 'magic-particles';
                        particle.style.animationDelay = `${i * 0.4}s`;
                        particle.style.right = `${50 + Math.random() * 40}px`;
                        particle.style.bottom = `${20 + Math.random() * 30}px`;
                        animationScene.appendChild(particle);
                    }
                    break;
                    
                case 'combat':
                    // Create combat elements
                    const warrior = document.createElement('div');
                    warrior.className = 'character';
                    warrior.style.background = '#ef4444';
                    
                    // Add enemies
                    for (let i = 0; i < 3; i++) {
                        const enemy = document.createElement('div');
                        enemy.className = 'character';
                        enemy.style.background = '#4b5563';
                        enemy.style.width = '20px';
                        enemy.style.height = '25px';
                        enemy.style.left = `${180 + i * 40}px`;
                        enemy.style.animation = 'characterIdle 1.2s infinite alternate';
                        enemy.style.animationDelay = `${i * 0.2}s`;
                        animationScene.appendChild(enemy);
                    }
                    
                    animationScene.appendChild(warrior);
                    break;
            }
        }
        
        // Start Pomodoro timer
        function startPomodoroTimer() {
            if (!state.activePomodoro) return;
            
            // Update UI
            document.getElementById('startTimer').disabled = true;
            document.getElementById('pauseTimer').disabled = false;
            
            // Set start time if not already running
            if (!state.activePomodoro.startTime) {
                state.activePomodoro.startTime = new Date().getTime();
            }
            
            state.activePomodoro.running = true;
            saveState();
            
            // Start timer update interval
            updatePomodoroTimer();
        }
        
        // Update Pomodoro timer
        function updatePomodoroTimer() {
            if (!state.activePomodoro || !state.activePomodoro.running) return;
            
            const now = new Date().getTime();
            const elapsed = Math.floor((now - state.activePomodoro.startTime) / 1000);
            const phaseDuration = state.activePomodoro.phase === 'focus' ? 
                                 state.activePomodoro.focusDuration * 60 : 
                                 state.activePomodoro.breakDuration * 60;
                                 
            state.activePomodoro.timeRemaining = Math.max(0, phaseDuration - elapsed);
            state.activePomodoro.lastActive = now;
            
            // Update display
            const minutes = Math.floor(state.activePomodoro.timeRemaining / 60);
            const seconds = state.activePomodoro.timeRemaining % 60;
            document.getElementById('timerDisplay').textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Check if timer is complete
            if (state.activePomodoro.timeRemaining <= 0) {
                handlePomodoroPhaseComplete();
            } else {
                // Continue timer
                saveState();
                setTimeout(updatePomodoroTimer, 1000);
            }
        }
        
        // Handle Pomodoro phase completion
        function handlePomodoroPhaseComplete() {
            // Pause the timer
            state.activePomodoro.running = false;
            
            if (state.activePomodoro.phase === 'focus') {
                // Completed a focus session
                state.activePomodoro.sessionsCompleted++;
                
                document.getElementById('completedPomodoros').textContent = state.activePomodoro.sessionsCompleted;
                
                // Show subtask completion prompt
                document.getElementById('pomodoroTimer').style.display = 'none';
                document.getElementById('subtaskCompletePrompt').classList.add('show');
                
                const taskIndex = state.activePomodoro.taskIndex;
                const subtaskIndex = state.activePomodoro.subtaskIndex;
                const task = state.tasks[taskIndex];
                const subtask = task.subtasks[subtaskIndex];
                
                document.getElementById('completionSubtaskName').textContent = subtask.name;
                
                // Play completion sound
                // const sound = new Audio('completion.mp3');
                // sound.play();
            } else {
                // Completed a break phase
                // Switch back to focus phase
                state.activePomodoro.phase = 'focus';
                state.activePomodoro.timeRemaining = state.activePomodoro.focusDuration * 60; // reset to full focus time
                state.activePomodoro.startTime = null;
                
                // Update phase display
                document.getElementById('phaseType').textContent = 'Focus Time';
                document.getElementById('phaseType').className = 'focus-time';
                document.getElementById('timerDisplay').textContent = `${state.activePomodoro.focusDuration}:00`;
                
                // Show timer screen
                document.getElementById('pomodoroTimer').style.display = 'block';
                document.getElementById('subtaskCompletePrompt').classList.remove('show');
                
                // Reset buttons
                document.getElementById('startTimer').disabled = false;
                document.getElementById('pauseTimer').disabled = true;
                
                showNotification(`Break complete! Ready for next focus session.`);
            }
            
            saveState();
        }
        
        // Handle subtask completion response
        function handleSubtaskComplete(isCompleted) {
            const taskIndex = state.activePomodoro.taskIndex;
            const subtaskIndex = state.activePomodoro.subtaskIndex;
            const task = state.tasks[taskIndex];
            
            if (isCompleted) {
                // Mark subtask as completed
                task.subtasks[subtaskIndex].completed = true;
                
                // Store how many sessions were needed for completion
                state.activePomodoro.sessionsForCompletion = state.activePomodoro.sessionsCompleted;
                
                // Award XP for completing subtask
                addXP(15);
                
                // Update pomodoro stats
                task.pomodoroStats.completedSessions += state.activePomodoro.sessionsCompleted;
                task.pomodoroStats.sessionsUsed += state.activePomodoro.sessionsCompleted;
                
                // Calculate efficiency bonus - the fewer sessions needed, the bigger the bonus
                // We use a baseline of 2 sessions to determine efficiency
                const expectedSessions = 2;
                const efficiencyBonus = Math.max(0, Math.min(30, Math.round((expectedSessions / state.activePomodoro.sessionsCompleted) * 20)));
                
                // Update loot bonus chance
                task.pomodoroStats.lootBonusPercent = Math.min(50, task.pomodoroStats.lootBonusPercent + efficiencyBonus);
                
                // Log the session
                task.pomodoroStats.sessionHistory.push({
                    subtask: task.subtasks[subtaskIndex].name,
                    sessions: state.activePomodoro.sessionsCompleted,
                    efficiencyBonus: efficiencyBonus,
                    completed: true,
                    timestamp: new Date().toISOString()
                });
                
                // Update bonus display
                document.getElementById('efficiencyBonus').textContent = efficiencyBonus;
                
                showNotification(`Subtask completed! +15 XP, Loot bonus +${efficiencyBonus}%!`);
                
                // Close the pomodoro modal
                setTimeout(() => {
                    closePomodoroModal();
                }, 2000);
            } else {
                // Continue with the task - switch to break phase
                state.activePomodoro.phase = 'rest';
                state.activePomodoro.timeRemaining = state.activePomodoro.breakDuration * 60;
                state.activePomodoro.startTime = null;
                
                // Update phase display
                document.getElementById('phaseType').textContent = 'Rest Time';
                document.getElementById('phaseType').className = 'rest-time';
                document.getElementById('timerDisplay').textContent = `${state.activePomodoro.breakDuration}:00`;
                
                // Show timer screen again
                document.getElementById('pomodoroTimer').style.display = 'block';
                document.getElementById('subtaskCompletePrompt').classList.remove('show');
                
                // Reset buttons
                document.getElementById('startTimer').disabled = false;
                document.getElementById('pauseTimer').disabled = true;
                
                // Log the incomplete session
                task.pomodoroStats.sessionsUsed += state.activePomodoro.sessionsCompleted;
                task.pomodoroStats.sessionHistory.push({
                    subtask: task.subtasks[subtaskIndex].name,
                    sessions: state.activePomodoro.sessionsCompleted,
                    completed: false,
                    timestamp: new Date().toISOString()
                });
            }
            
            saveState();
        }
        
        // Pause Pomodoro timer
        function pausePomodoroTimer() {
            if (!state.activePomodoro) return;
            
            state.activePomodoro.running = false;
            saveState();
            
            // Update UI
            document.getElementById('startTimer').disabled = false;
            document.getElementById('pauseTimer').disabled = true;
        }
        
        // Skip current Pomodoro phase
        function skipPomodoroPhase() {
            if (!state.activePomodoro) return;
            
            if (state.activePomodoro.phase === 'focus') {
                // If skipping focus phase, don't count it as completed
                handlePomodoroPhaseComplete();
            } else {
                // Simply end the break phase
                state.activePomodoro.phase = 'focus';
                state.activePomodoro.timeRemaining = state.activePomodoro.focusDuration * 60;
                state.activePomodoro.startTime = null;
                
                // Update phase display
                document.getElementById('phaseType').textContent = 'Focus Time';
                document.getElementById('phaseType').className = 'focus-time';
                document.getElementById('timerDisplay').textContent = `${state.activePomodoro.focusDuration}:00`;
                
                // Reset buttons
                document.getElementById('startTimer').disabled = false;
                document.getElementById('pauseTimer').disabled = true;
            }
            
            state.activePomodoro.running = false;
            saveState();
        }
        
        // Abandon pomodoro session
        function abandonPomodoroSession() {
            // If any sessions were completed, still count them
            if (state.activePomodoro && state.activePomodoro.sessionsCompleted > 0) {
                const taskIndex = state.activePomodoro.taskIndex;
                const subtaskIndex = state.activePomodoro.subtaskIndex;
                const task = state.tasks[taskIndex];
                
                if (task && task.subtasks && task.subtasks[subtaskIndex]) {
                    // Log the abandoned session
                    task.pomodoroStats.sessionsUsed += state.activePomodoro.sessionsCompleted;
                    task.pomodoroStats.sessionHistory.push({
                        subtask: task.subtasks[subtaskIndex].name,
                        sessions: state.activePomodoro.sessionsCompleted,
                        completed: false,
                        abandoned: true,
                        timestamp: new Date().toISOString()
                    });
                }
            }
            
            state.activePomodoro = null;
            saveState();
            closePomodoroModal();
        }
        
        // Close Pomodoro modal
        function closePomodoroModal() {
            document.getElementById('pomodoroModal').classList.remove('show');
            
            // If timer was running, pause it
            if (state.activePomodoro && state.activePomodoro.running) {
                pausePomodoroTimer();
            }
            
            updateUI();
        }

        // Complete task with chance for critical success and pomodoro bonus
        function completeTask(index) {
            const task = state.tasks[index];
            if (!task.completed) {
                // Log completion time to history (for anti-farming)
                state.completionHistory.push(new Date().toISOString());
                
                // Roll dice for critical success
                const diceContainer = document.getElementById('diceRollDisplay');
                diceContainer.innerHTML = '';
                diceContainer.classList.add('show');
                
                // Create and show dice
                const dice = document.createElement('div');
                dice.className = 'dice';
                diceContainer.appendChild(dice);
                
                // Mark as completed first to prevent double-clicks
                task.completed = true;
                
                // Adjust completion UI
                const taskElements = document.querySelectorAll('.task-list li');
                if (taskElements[index]) {
                    const completeBtn = taskElements[index].querySelector('.complete-btn');
                    if (completeBtn) {
                        completeBtn.disabled = true;
                        completeBtn.textContent = 'Rolling...';
                    }
                }
                
                // Animate dice roll
                setTimeout(() => {
                    // Roll the dice
                    const roll = Math.floor(Math.random() * 20) + 1; // d20
                    dice.textContent = roll;
                    
                    // Determine if critical success with pomodoro bonus
                    let criticalSuccess = false;
                    let criticalFail = false;
                    
                    // Pomodoro bonus increases critical chance
                    const pomodoroBonus = task.pomodoroStats ? task.pomodoroStats.lootBonusPercent / 100 : 0;
                    
                    // Base critical chance
                    if (roll === 20) {
                        criticalSuccess = true;
                    } 
                    // Streak + Pomodoro increases critical chance
                    else if (roll >= (20 - Math.min(5, Math.floor(state.streak / 2)) - Math.floor(pomodoroBonus * 10))) {
                        criticalSuccess = true;
                    }
                    // Very small chance of critical fail
                    else if (roll === 1) {
                        criticalFail = true;
                    }
                    
                    // Apply streak bonus
                    let bonus = 1 + (state.streak * 0.1);
                    
                    // Apply early completion bonus
                    const daysEarly = Math.max(0, (new Date(task.deadline) - new Date()) / (1000 * 60 * 60 * 24));
                    const earlyBonus = daysEarly * 0.05;
                    bonus += earlyBonus;
                    
                    // Apply pomodoro bonus
                    if (pomodoroBonus > 0) {
                        bonus += pomodoroBonus;
                    }
                    
                    // Calculate subtask completion bonus
                    const subtaskCompletionRate = task.subtasks.length ? 
                       task.subtasks.filter(subtask => subtask.completed).length / task.subtasks.length : 0;
                    
                    const subtaskBonus = subtaskCompletionRate * 0.15; // Up to 15% bonus for all subtasks
                    bonus += subtaskBonus;
                    
                    // Rarity multipliers for more variance
                    const rarityMultipliers = {
                        'common': 1,
                        'uncommon': 1.2,
                        'rare': 1.5,
                        'epic': 2,
                        'legendary': 3
                    };
                    
                    // Base credits calculation
                    let creditsEarned = Math.round(task.credits * bonus * rarityMultipliers[task.rarity]);
                    let xpEarned = task.xp;
                    
                    if (criticalSuccess) {
                        // Critical success - double rewards!
                        creditsEarned = Math.round(creditsEarned * 2);
                        xpEarned = Math.round(xpEarned * 2);
                        dice.style.background = 'var(--legendary)';
                        dice.style.boxShadow = '0 0 10px var(--legendary)';
                    } else if (criticalFail) {
                        // Critical fail - half rewards
                        creditsEarned = Math.round(creditsEarned * 0.5);
                        xpEarned = Math.round(xpEarned * 0.5);
                        dice.style.background = 'var(--danger)';
                    } else {
                        dice.style.background = 'var(--primary)';
                    }
                    
                    // Update player stats
                    state.credits += creditsEarned;
                    state.streak++;
                    state.lastStreak = new Date().toDateString();
                    addXP(xpEarned);
                    
                    // If this was the active pomodoro task, clear it
                    if (state.activePomodoro && state.activePomodoro.taskIndex === index) {
                        state.activePomodoro = null;
                    }
                    
                    // Show the result message
                    let message = '';
                    if (criticalSuccess) {
                        message = `üåü CRITICAL SUCCESS! +${creditsEarned} credits, +${xpEarned} XP`;
                    } else if (criticalFail) {
                        message = `üòì Critical fail... +${creditsEarned} credits, +${xpEarned} XP`;
                    } else {
                        message = `Quest completed! +${creditsEarned} credits, +${xpEarned} XP`;
                        if (state.streak > 1) {
                            message += ` (${state.streak}x streak bonus!)`;
                        }
                        if (earlyBonus > 0) {
                            message += ` (Early completion bonus!)`;
                        }
                        if (pomodoroBonus > 0) {
                            message += ` (Pomodoro bonus: ${Math.round(pomodoroBonus * 100)}%!)`;
                        }
                        if (subtaskBonus > 0) {
                            message += ` (Subtask bonus: ${Math.round(subtaskBonus * 100)}%!)`;
                        }
                    }
                    
                    // Chance for bonus loot for higher rarity tasks (Easter egg)
                    if (['rare', 'epic', 'legendary'].includes(task.rarity) && Math.random() < 0.3) {
                        const bonusCredits = Math.round(task.credits * 0.2);
                        state.credits += bonusCredits;
                        message += ` BONUS LOOT: +${bonusCredits} credits!`;
                    }
                    
                    // Additional chance for bonus with pomodoro sessions
                    if (task.pomodoroStats && task.pomodoroStats.completedSessions > 0 && Math.random() < pomodoroBonus) {
                        const pomodoroBonus = Math.round(task.credits * 0.3);
                        state.credits += pomodoroBonus;
                        message += ` POMODORO CHEST: +${pomodoroBonus} credits!`;
                    }
                    
                    // Show notification after roll
                    setTimeout(() => {
                        showNotification(message);
                    }, 500);
                    
                    saveState();
                    updateWishlistProgress();
                    updateUI();
                }, 750);
                
                // Hide dice after animation
                setTimeout(() => {
                    diceContainer.classList.remove('show');
                }, 3000);
            }
        }
        
        // Abandon task (with penalty)
        function abandonTask(index) {
            const task = state.tasks[index];
            if (!task.completed) {
                // Apply penalty
                const penalty = Math.round(task.credits * 0.25);
                state.credits = Math.max(0, state.credits - penalty);
                
                // Reset streak
                state.streak = 0;
                
                // Show notification
                showNotification(`Quest abandoned! -${penalty} credits. Streak reset!`, 'danger');
                
                // If this was the active pomodoro task, clear it
                if (state.activePomodoro && state.activePomodoro.taskIndex === index) {
                    state.activePomodoro = null;
                }
                
                // Remove task
                state.tasks.splice(index, 1);
                
                saveState();
                updateUI();
            }
        }

        // Update wishlist progress with psychological enhancements
        function updateWishlistProgress() {
            state.wishlist.forEach(item => {
                // Store previous progress for milestone checking
                const previousProgress = item.progress / item.credits;
                
                // Base progress as a proportion of total credits needed
                let baseProgress = Math.min(state.credits, item.credits - item.progress);
                
                // Goal-gradient effect - acceleration in final stretch
                if ((item.progress / item.credits) > 0.7 && (item.progress / item.credits) < 1) {
                    const goalGradientBonus = baseProgress * 0.1; // 10% bonus in final stretch
                    baseProgress += goalGradientBonus;
                }
                
                // Check if the user can allocate credits to this item
                if (baseProgress > 0) {
                    // Update item progress
                    item.progress += baseProgress;
                    state.credits -= baseProgress;
                    
                    // Update display progress with visual enhancement
                    item.displayProgress = Math.min(1, item.progress / item.credits);
                    
                    // Check for milestones
                    item.milestones.forEach(milestone => {
                        if (previousProgress < milestone && item.displayProgress >= milestone) {
                            if (!state.milestones[item.id] || !state.milestones[item.id].includes(milestone)) {
                                if (!state.milestones[item.id]) state.milestones[item.id] = [];
                                state.milestones[item.id].push(milestone);
                                
                                const percentComplete = Math.round(milestone * 100);
                                showNotification(`${percentComplete}% progress on "${item.name}"!`);
                                
                                // Add XP for milestone
                                if (milestone < 1) {
                                    addXP(Math.round(milestone * 50));
                                }
                            }
                        }
                    });
                    
                    // Check if item is now complete
                    if (item.displayProgress >= 1 && (!state.milestones[item.id] || !state.milestones[item.id].includes('completed'))) {
                        if (!state.milestones[item.id]) state.milestones[item.id] = [];
                        state.milestones[item.id].push('completed');
                        showNotification(`üéâ Reward unlocked: "${item.name}"! üéâ`);
                        
                        // Bonus XP for completion
                        addXP(100);
                    }
                }
            });
            
            saveState();
        }

        // Update UI
        function updateUI() {
            // Update credits and level display
            document.getElementById('totalCredits').textContent = state.credits;
            document.getElementById('currentStreak').textContent = state.streak;
            document.getElementById('playerLevel').textContent = state.level;
            document.getElementById('currentXP').textContent = state.xp;
            document.getElementById('xpToNextLevel').textContent = state.xpToNextLevel;
            document.getElementById('levelProgress').style.width = `${(state.xp / state.xpToNextLevel) * 100}%`;

            // Update tasks list
            const taskList = document.getElementById('taskList');
            taskList.innerHTML = state.tasks
                .filter(task => !task.completed) // Show only uncompleted tasks
                .map((task, index) => {
                    const actualIndex = state.tasks.indexOf(task);
                    
                    // Format deadline with urgency coloring
                    const today = new Date();
                    const deadline = new Date(task.deadline);
                    const daysRemaining = Math.floor((deadline - today) / (1000 * 60 * 60 * 24));
                    
                    let deadlineClass = '';
                    if (daysRemaining < 0) {
                        deadlineClass = 'style="color: var(--danger); font-weight: bold;"';
                    } else if (daysRemaining < 2) {
                        deadlineClass = 'style="color: var(--warning); font-weight: bold;"';
                    }
                    
                    // Determine streak bonus
                    const streakBonus = Math.round(task.credits * state.streak * 0.1);
                    
                    // Get rarity name with proper capitalization
                    const rarityName = task.rarity.charAt(0).toUpperCase() + task.rarity.slice(1);
                    
                    // Show pomodoro progress if applicable
                    let pomodoroProgress = '';
                    if (task.pomodoroStats && task.pomodoroStats.lootBonusPercent > 0) {
                        pomodoroProgress = `
                            <div style="margin-top: 0.5rem;">
                                <span style="font-size: 0.8rem;">Pomodoro bonus: +${task.pomodoroStats.lootBonusPercent}% chance of bonus rewards</span>
                            </div>
                        `;
                    }
                    
                    // Show subtasks if any
                    let subtasksHTML = '';
                    if (task.subtasks && task.subtasks.length > 0) {
                        const completedSubtasks = task.subtasks.filter(st => st.completed).length;
                        const subtaskPercent = Math.round((completedSubtasks / task.subtasks.length) * 100);
                        
                        subtasksHTML = `
                            <div style="margin-top: 0.5rem;">
                                <span style="font-size: 0.8rem;">Subtasks: ${completedSubtasks}/${task.subtasks.length} (${subtaskPercent}%)</span>
                                <div class="progress-bar" style="height: 0.5rem;">
                                    <div class="progress-bar-fill" style="width: ${subtaskPercent}%;"></div>
                                </div>
                            </div>
                        `;
                    }
                    
                    return `
                    <li class="${task.rarity}">
                        <div class="task-info">
                            <div class="task-header">
                                <div class="quest-icon">${task.icon}</div>
                                <strong>${task.name}</strong> <span style="font-size: 0.8em; color: var(--${task.rarity === 'common' ? 'secondary' : task.rarity});">[${rarityName}]</span>
                            </div>
                            <div style="margin-top: 0.5rem;">
                                ${task.importance}‚òÖ | ${task.timeEstimate}h | Due: <span ${deadlineClass}>${task.deadline}</span><br>
                                Reward: ${task.credits} credits (+${streakBonus} streak bonus), ${task.xp} XP
                                <div class="tooltip">‚ìò
                                    <span class="tooltiptext">
                                        Critical success chance: ${5 + Math.min(5, Math.floor(state.streak / 2))}%<br>
                                        Pomodoro bonus: +${task.pomodoroStats ? task.pomodoroStats.lootBonusPercent : 0}%<br>
                                        Total critical chance: ${5 + Math.min(5, Math.floor(state.streak / 2)) + (task.pomodoroStats ? task.pomodoroStats.lootBonusPercent : 0)}%
                                    </span>
                                </div>
                            </div>
                            ${pomodoroProgress}
                            ${subtasksHTML}
                        </div>
                        <div class="task-buttons">
                            <button onclick="startPomodoro(${actualIndex})" class="pomodoro-btn">Pomodoro</button>
                            <button onclick="completeTask(${actualIndex})" class="complete-btn">Complete</button>
                            <button onclick="abandonTask(${actualIndex})" class="abandon-btn">Abandon</button>
                        </div>
                    </li>
                `})
                .join('');

            // Add completed tasks at the bottom (show only most recent 5)
            const completedTasks = state.tasks
                .filter(task => task.completed)
                .sort((a, b) => new Date(b.completed) - new Date(a.completed))
                .slice(0, 5)
                .map((task) => `
                    <li style="opacity: 0.7;" class="${task.rarity}">
                        <div>
                            <div class="task-header">
                                <div class="quest-icon">${task.icon}</div>
                                <strong>${task.name}</strong> <span style="font-size: 0.8em; color: var(--${task.rarity === 'common' ? 'secondary' : task.rarity});">[${task.rarity.charAt(0).toUpperCase() + task.rarity.slice(1)}]</span>
                            </div>
                            ${task.importance}‚òÖ | ${task.timeEstimate}h | Completed
                        </div>
                        <span style="color: var(--success)">‚úì Done</span>
                    </li>
                `)
                .join('');
                
            if (completedTasks) {
                taskList.innerHTML += `<h4>Completed quests</h4>${completedTasks}`;
            }

            // Update wishlist with enhanced progress display
            const wishlist = document.getElementById('wishlist');
            wishlist.innerHTML = state.wishlist
                .map((item, index) => {
                    // Build milestone markers
                    const milestonesHTML = item.milestones
                        .map(milestone => `
                            <div class="milestone" style="left: ${milestone * 100}%;"></div>
                        `)
                        .join('');
                    
                    // Calculate progress and display progress
                    const progressPercent = (item.progress / item.credits) * 100;
                    const displayProgressPercent = item.displayProgress * 100;
                    
                    // Check if item is complete
                    const isComplete = displayProgressPercent >= 100;
                    
                    return `
                    <li>
                        <div style="width: 100%;">
                            <div class="reward-header">
                                <div class="reward-icon">${item.icon}</div>
                                <strong>${item.name}</strong> ${isComplete ? '‚úÖ' : ''}
                            </div>
                            <div style="margin-top: 0.5rem;">
                                ${item.cost} HKD | ${item.timeline} weeks | Desire: ${item.desireLevel}/5
                                <br>
                                ${Math.round(progressPercent)}% complete | ${Math.round(item.progress)}/${item.credits} credits
                            </div>
                            <div class="progress-bar" style="position: relative;">
                                ${milestonesHTML}
                                <div class="progress-bar-fill" style="width: ${Math.min(100, displayProgressPercent)}%"></div>
                            </div>
                        </div>
                    </li>
                `})
                .join('');
        }

        // Initialize
        loadState();

        // Daily credit decay (check on page load)
        const lastDecay = localStorage.getItem('lastCreditDecay');
        const now = new Date().toDateString();
        if (lastDecay !== now) {
            // Apply a small decay to maintain engagement
            state.credits = Math.max(0, Math.round(state.credits * 0.98));
            localStorage.setItem('lastCreditDecay', now);
            saveState();
        }

        // Auto-update wishlist progress when page loads
        updateWishlistProgress();
        updateUI();
    </script>
</body>
</html>
