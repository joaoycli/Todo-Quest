<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest Todo - Productivity RPG</title>
    <style>
        :root {
            --primary: #4f46e5;
            --secondary: #818cf8;
            --success: #22c55e;
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #0ea5e9;
            --rare: #9333ea;
            --epic: #c026d3;
            --legendary: #fbbf24;
            --focus: #7dd3fc;
            --rest: #f43f5e;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f3f4f6;
            color: #1f2937;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .stats {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .credits {
            background: var(--primary);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }

        .streak {
            background: var(--warning);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }

        .level {
            background: var(--info);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .card {
            background: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .card h2 {
            margin-top: 0;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 0.5rem;
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(1px);
        }

        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        input, select {
            width: 100%;
            padding: 0.5rem;
            margin-bottom: 1rem;
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
        }

        .task-list, .wishlist {
            list-style: none;
            padding: 0;
        }

        .task-list li, .wishlist li {
            background: #f9fafb;
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .task-list li:hover, .wishlist li:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .common {
            border-left: 4px solid #9ca3af;
        }

        .uncommon {
            border-left: 4px solid var(--success);
        }

        .rare {
            border-left: 4px solid var(--rare);
        }

        .epic {
            border-left: 4px solid var(--epic);
        }

        .legendary {
            border-left: 4px solid var(--legendary);
            background: linear-gradient(to right, #fef3c7, #f9fafb 30%);
        }

        .progress-bar {
            background: #e5e7eb;
            height: 1rem;
            border-radius: 0.5rem;
            overflow: hidden;
            margin-top: 0.5rem;
            position: relative;
        }

        .progress-bar-fill {
            background: var(--success);
            height: 100%;
            transition: width 0.3s ease;
        }

        .milestone {
            position: absolute;
            height: 100%;
            width: 2px;
            background: var(--warning);
        }

        .tooltip {
            position: relative;
            display: inline-block;
            margin-left: 0.5rem;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .reward-notification {
            background: var(--primary);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-size: 1.25rem;
            font-weight: bold;
            transition: transform 0.5s, opacity 0.5s;
            transform: translateY(20px);
            opacity: 0;
        }

        .dice-roll {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 1rem 0;
            gap: 1rem;
            height: 0;
            overflow: hidden;
            transition: height 0.3s ease;
        }

        .dice-roll.show {
            height: 60px;
        }

        .dice {
            width: 50px;
            height: 50px;
            background: var(--primary);
            color: white;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            animation: roll 0.75s ease-out;
        }

        @keyframes roll {
            0% { transform: rotateZ(0deg); }
            100% { transform: rotateZ(720deg); }
        }

        .bonus-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            z-index: 1001;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            max-width: 90%;
            width: 400px;
        }

        .bonus-card.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: all;
        }

        .bonus-card-options {
            display: flex;
            justify-content: space-around;
            margin-top: 2rem;
        }

        .bonus-option {
            padding: 1rem;
            border-radius: 0.5rem;
            background: #f9fafb;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            margin: 0 0.5rem;
            border: 2px solid transparent;
        }

        .bonus-option:hover {
            transform: translateY(-2px);
            border-color: var(--primary);
        }

        .level-bar {
            background: #e5e7eb;
            height: 0.5rem;
            border-radius: 0.25rem;
            overflow: hidden;
            margin-top: 0.5rem;
            width: 100px;
        }

        .level-bar-fill {
            background: var(--info);
            height: 100%;
            transition: width 0.3s ease;
        }

        .level-container {
            display: flex;
            align-items: center;
        }

        .loot-table {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .loot-item {
            background: #f9fafb;
            padding: 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .rarity-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .task-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .task-info {
            flex: 1;
        }

        .pomodoro-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .pomodoro-modal.show {
            opacity: 1;
            pointer-events: all;
        }

        .pomodoro-container {
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .timer-display {
            font-size: 3rem;
            text-align: center;
            margin: 2rem 0;
            font-weight: bold;
        }

        .phase-indicator {
            text-align: center;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            font-weight: bold;
        }

        .timer-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .focus-time {
            color: var(--focus);
        }

        .rest-time {
            color: var(--rest);
        }

        .pomodoro-stats {
            background: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
        }

        .pomodoro-progress {
            display: flex;
            margin-top: 1rem;
        }

        .pomodoro-segment {
            flex: 1;
            height: 8px;
            margin: 0 2px;
            border-radius: 4px;
            background: #e5e7eb;
        }

        .pomodoro-segment.completed {
            background: var(--success);
        }

        .pomodoro-segment.current {
            background: var(--focus);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .quest-icon, .reward-icon {
            font-size: 1.5rem;
            margin-right: 0.5rem;
            width: 2rem;
            height: 2rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: #f3f4f6;
            border-radius: 50%;
        }

        .task-header, .reward-header {
            display: flex;
            align-items: center;
        }

        .subtasks {
            margin-top: 0.5rem;
            padding-left: 1rem;
            border-left: 2px dashed #e5e7eb;
        }

        .subtask-item {
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            background: #f3f4f6;
            border-radius: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .subtask-completed {
            text-decoration: line-through;
            opacity: 0.7;
        }

        .pomodoro-btn {
            background: var(--focus);
        }

        .complete-btn {
            background: var(--success);
        }

        .abandon-btn {
            background: var(--danger);
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .task-list li {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .task-buttons {
                width: 100%;
                margin-top: 1rem;
                justify-content: space-between;
            }
            
            .stats {
                flex-direction: column;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="celebration">
        <div class="reward-notification"></div>
    </div>
    
    <div class="bonus-card">
        <h2>Bonus Challenge!</h2>
        <p>Choose your reward path:</p>
        <div class="bonus-card-options">
            <div class="bonus-option" onclick="selectBonusOption('safe')">
                <h3>Safe</h3>
                <p>Guaranteed <span id="safeAmount">20</span> credits</p>
            </div>
            <div class="bonus-option" onclick="selectBonusOption('risky')">
                <h3>Risky</h3>
                <p>50% chance of <span id="riskyAmount">40</span> credits</p>
            </div>
            <div class="bonus-option" onclick="selectBonusOption('epic')">
                <h3>Epic</h3>
                <p>20% chance of <span id="epicAmount">100</span> credits</p>
            </div>
        </div>
    </div>
    
    <div class="pomodoro-modal" id="pomodoroModal">
        <div class="pomodoro-container">
            <h2 id="pomodoroTaskName">Task Name</h2>
            <div class="phase-indicator">
                <span id="phaseType" class="focus-time">Focus Time</span>
            </div>
            <div class="timer-display" id="timerDisplay">25:00</div>
            <div class="timer-controls">
                <button id="startTimer" onclick="startPomodoroTimer()">Start</button>
                <button id="pauseTimer" onclick="pausePomodoroTimer()" disabled>Pause</button>
                <button id="skipTimer" onclick="skipPomodoroPhase()">Skip</button>
                <button onclick="closePomodoroModal()">Exit</button>
            </div>
            
            <div class="pomodoro-progress" id="pomodoroProgress">
                <!-- Pomodoro segments will be added here -->
            </div>
            
            <div class="pomodoro-stats">
                <h3>Pomodoro Stats</h3>
                <p>Completed: <span id="completedPomodoros">0</span> / <span id="totalPomodoros">4</span></p>
                <p>Loot Bonus: +<span id="lootBonus">0</span>% chance of bonus rewards</p>
            </div>
            
            <div class="subtasks" id="subtasksList">
                <h3>Subtasks</h3>
                <div class="subtask-form">
                    <input type="text" id="subtaskInput" placeholder="Add a subtask">
                    <button onclick="addSubtask()">Add</button>
                </div>
                <div id="subtasksContainer">
                    <!-- Subtasks will be added here -->
                </div>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="header">
            <h1>Quest Todo</h1>
            <div class="stats">
                <div class="level-container">
                    <div class="level">Level <span id="playerLevel">1</span></div>
                    <div style="margin-left: 0.5rem;">
                        <div class="level-bar">
                            <div class="level-bar-fill" id="levelProgress" style="width: 0%"></div>
                        </div>
                        <div style="font-size: 0.75rem; text-align: center;"><span id="currentXP">0</span>/<span id="xpToNextLevel">100</span> XP</div>
                    </div>
                </div>
                <div class="streak">Streak: <span id="currentStreak">0</span> days</div>
                <div class="credits">Credits: <span id="totalCredits">0</span></div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>Add Quest</h2>
                <form id="taskForm">
                    <input type="text" id="taskName" placeholder="Quest name" required>
                    <input type="number" id="timeEstimate" placeholder="Time estimate (hours)" required min="0" step="0.5">
                    <select id="importance" required>
                        <option value="">Select difficulty</option>
                        <option value="1">Easy ★</option>
                        <option value="2">Normal ★★</option>
                        <option value="3">Hard ★★★</option>
                        <option value="4">Very Hard ★★★★</option>
                        <option value="5">Epic ★★★★★</option>
                    </select>
                    <input type="date" id="deadline" required>
                    <button type="submit">Create Quest</button>
                </form>
                
                <div class="dice-roll" id="diceRollDisplay">
                    <!-- Dice will be injected here when rolling -->
                </div>
                
                <div style="margin-top: 1rem;">
                    <h3>Loot Table</h3>
                    <div class="loot-table">
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: #9ca3af;"></div>
                            Common (60%)
                        </div>
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: var(--success);"></div>
                            Uncommon (25%)
                        </div>
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: var(--rare);"></div>
                            Rare (10%)
                        </div>
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: var(--epic);"></div>
                            Epic (4%)
                        </div>
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: var(--legendary);"></div>
                            Legendary (1%)
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>Add Reward</h2>
                <form id="wishlistForm">
                    <input type="text" id="itemName" placeholder="Reward name" required>
                    <input type="number" id="itemCost" placeholder="Cost (HKD)" required min="0">
                    <input type="number" id="timeline" placeholder="Timeline (weeks)" required min="1">
                    <select id="desireLevel" required>
                        <option value="">How much do you want this?</option>
                        <option value="1">Nice to have</option>
                        <option value="2">Want it</option>
                        <option value="3">Really want it</option>
                        <option value="4">Desperately want it</option>
                        <option value="5">Must have it!</option>
                    </select>
                    <button type="submit">Add Reward</button>
                </form>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>Active Quests</h2>
                <ul id="taskList" class="task-list"></ul>
            </div>

            <div class="card">
                <h2>Rewards</h2>
                <ul id="wishlist" class="wishlist"></ul>
            </div>
        </div>
    </div>

    <script>
        // State management
        let state = {
            tasks: [],
            wishlist: [],
            credits: 0,
            streak: 0,
            lastStreak: new Date().toDateString(),
            notifications: [],
            milestones: {},
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            lastDaily: null,
            bonusChallenge: null,
            completionHistory: [],
            activePomodoro: null
        };
        
        // Icon mapping for common quest and reward types
        const iconMappings = {
            // Work and study related
            "work": "💼",
            "study": "📚",
            "code": "💻",
            "program": "💻",
            "programming": "💻",
            "coding": "💻",
            "assignment": "📝",
            "homework": "📚",
            "project": "🏗️",
            "research": "🔬",
            "presentation": "📊",
            "meeting": "👥",
            "email": "📧",
            "write": "✍️",
            "writing": "✍️",
            "read": "📖",
            "reading": "📖",
            "learn": "🧠",
            "course": "🎓",
            "class": "🏫",
            "lecture": "🎓",
            "test": "📝",
            "exam": "📝",
            "quiz": "❓",
            
            // Health related
            "workout": "💪",
            "exercise": "🏃",
            "run": "🏃",
            "gym": "🏋️",
            "fitness": "🏋️",
            "yoga": "🧘",
            "meditate": "🧘",
            "meditation": "🧘",
            "sleep": "😴",
            "diet": "🥗",
            "eat": "🍽️",
            "cook": "🍳",
            "cooking": "🍳",
            "health": "❤️",
            "doctor": "🩺",
            "dentist": "🦷",
            
            // Home related
            "clean": "🧹",
            "cleaning": "🧹",
            "laundry": "🧺",
            "dishes": "🍽️",
            "groceries": "🛒",
            "shopping": "🛍️",
            "organize": "📋",
            "pack": "📦",
            "unpack": "📦",
            "move": "🚚",
            "repair": "🔧",
            "fix": "🔧",
            "home": "🏠",
            "house": "🏠",
            "apartment": "🏢",
            
            // Leisure related
            "game": "🎮",
            "gaming": "🎮",
            "play": "🎮",
            "movie": "🎬",
            "tv": "📺",
            "show": "📺",
            "music": "🎵",
            "podcast": "🎧",
            "book": "📚",
            "novel": "📕",
            "art": "🎨",
            "draw": "✏️",
            "painting": "🎨",
            "craft": "🧶",
            
            // Travel related
            "travel": "✈️",
            "trip": "🧳",
            "vacation": "🏖️",
            "flight": "✈️",
            "drive": "🚗",
            "train": "🚂",
            "bus": "🚌",
            "taxi": "🚕",
            "hotel": "🏨",
            "booking": "📅",
            "reservation": "📅",
            "ticket": "🎫",
            "passport": "🛂",
            "visa": "🛂",
            
            // Social related
            "call": "📞",
            "phone": "📱",
            "text": "💬",
            "message": "💬",
            "social": "👥",
            "friend": "👫",
            "family": "👪",
            "party": "🎉",
            "event": "🎭",
            "date": "❤️",
            "gift": "🎁",
            "present": "🎁",
            "birthday": "🎂",
            "anniversary": "💍",
            "wedding": "💒",
            
            // Financial related
            "bill": "💰",
            "payment": "💳",
            "bank": "🏦",
            "pay": "💵",
            "money": "💰",
            "tax": "📑",
            "budget": "💹",
            "invest": "📈",
            "investment": "📈",
            "save": "💰",
            "savings": "💰",
            "expense": "💸",
            "debt": "💸",
            "loan": "💸",
            "insurance": "🔒",
            
            // Reward related
            "clothes": "👕",
            "shoes": "👟",
            "watch": "⌚",
            "jewelry": "💍",
            "accessory": "👓",
            "gadget": "🔌",
            "phone": "📱",
            "laptop": "💻",
            "computer": "🖥️",
            "camera": "📷",
            "headphone": "🎧",
            "speaker": "🔊",
            "game": "🎮",
            "console": "🎮",
            "toy": "🧸",
            "book": "📚",
            "subscription": "📱",
            "membership": "🔑",
            "ticket": "🎫",
            "trip": "✈️",
            "vacation": "🏖️",
            "restaurant": "🍽️",
            "dinner": "🍽️",
            "lunch": "🍽️",
            "coffee": "☕",
            "drink": "🍹",
            "spa": "💆",
            "massage": "💆",
            "movie": "🎬",
            "concert": "🎵",
            "show": "🎭",
            "gift": "🎁",
            "donation": "❤️",
            "charity": "❤️",
            "savings": "💰",
            "investment": "📈"
        };
        
        // Determine icon for a given text
        function determineIcon(text) {
            const lowerText = text.toLowerCase();
            
            // Look for keyword matches
            for (const [keyword, icon] of Object.entries(iconMappings)) {
                if (lowerText.includes(keyword)) {
                    return icon;
                }
            }
            
            // Default icons if no match found
            if (text.length % 5 === 0) return "🔮";
            if (text.length % 5 === 1) return "⚔️";
            if (text.length % 5 === 2) return "🛡️";
            if (text.length % 5 === 3) return "🧩";
            if (text.length % 5 === 4) return "📋";
            
            return "📝"; // Default fallback
        }

        // Load state from localStorage
        function loadState() {
            const savedState = localStorage.getItem('questTodoState');
            if (savedState) {
                state = JSON.parse(savedState);
                
                // Backward compatibility
                if (!state.level) state.level = 1;
                if (!state.xp) state.xp = 0;
                if (!state.xpToNextLevel) state.xpToNextLevel = 100;
                if (!state.completionHistory) state.completionHistory = [];
                if (!state.activePomodoro) state.activePomodoro = null;
                
                // Backward compatibility for icons
                state.tasks.forEach(task => {
                    if (!task.icon) {
                        task.icon = determineIcon(task.name);
                    }
                    if (!task.subtasks) {
                        task.subtasks = [];
                    }
                    if (!task.pomodoroStats) {
                        task.pomodoroStats = {
                            completed: 0,
                            total: 0,
                            lootBonusPercent: 0
                        };
                    }
                });
                
                state.wishlist.forEach(item => {
                    if (!item.icon) {
                        item.icon = determineIcon(item.name);
                    }
                });
                
                // Check if streak should continue or reset
                const today = new Date().toDateString();
                const lastStreakDate = new Date(state.lastStreak);
                const dayDiff = Math.floor((new Date() - lastStreakDate) / (1000 * 60 * 60 * 24));
                
                if (dayDiff > 1) {
                    // Reset streak if more than a day has passed
                    state.streak = 0;
                }
                
                // Check for active pomodoro session
                if (state.activePomodoro) {
                    // Resume active session or clean up if too much time has passed
                    const now = new Date().getTime();
                    const timeSinceLastActivity = now - state.activePomodoro.lastActive;
                    
                    if (timeSinceLastActivity > 30 * 60 * 1000) { // 30 minutes
                        // Too much time has passed, clean up
                        state.activePomodoro = null;
                    }
                }
                
                // Check for daily bonus challenge
                checkDailyChallenge();
                
                updateUI();
            }
        }

        // Save state to localStorage
        function saveState() {
            localStorage.setItem('questTodoState', JSON.stringify(state));
        }

        // Check for daily bonus challenge
        function checkDailyChallenge() {
            const today = new Date().toDateString();
            if (state.lastDaily !== today) {
                // 30% chance of bonus challenge
                if (Math.random() < 0.3) {
                    // Create bonus challenge
                    const baseAmount = 20 + (state.level * 5);
                    state.bonusChallenge = {
                        safeAmount: baseAmount,
                        riskyAmount: Math.round(baseAmount * 2),
                        epicAmount: Math.round(baseAmount * 5),
                        day: today
                    };
                    
                    // Update the UI with the amounts
                    document.getElementById('safeAmount').textContent = state.bonusChallenge.safeAmount;
                    document.getElementById('riskyAmount').textContent = state.bonusChallenge.riskyAmount;
                    document.getElementById('epicAmount').textContent = state.bonusChallenge.epicAmount;
                    
                    // Show the bonus challenge
                    setTimeout(() => {
                        document.querySelector('.bonus-card').classList.add('show');
                    }, 1000);
                }
                state.lastDaily = today;
                saveState();
            }
        }
        
        // Select bonus option
        function selectBonusOption(option) {
            let amount = 0;
            let message = '';
            
            switch(option) {
                case 'safe':
                    amount = state.bonusChallenge.safeAmount;
                    message = `Safe choice! +${amount} credits`;
                    break;
                case 'risky':
                    if (Math.random() < 0.5) {
                        amount = state.bonusChallenge.riskyAmount;
                        message = `Risky paid off! +${amount} credits`;
                    } else {
                        message = 'Took a risk but no reward this time!';
                    }
                    break;
                case 'epic':
                    if (Math.random() < 0.2) {
                        amount = state.bonusChallenge.epicAmount;
                        message = `EPIC WIN! +${amount} credits`;
                    } else {
                        message = 'Went for epic... but no luck today!';
                    }
                    break;
            }
            
            if (amount > 0) {
                state.credits += amount;
                addXP(Math.round(amount / 2));
            }
            
            document.querySelector('.bonus-card').classList.remove('show');
            showNotification(message);
            
            state.bonusChallenge = null;
            saveState();
            updateUI();
        }
        
        // Add XP and handle leveling up
        function addXP(amount) {
            state.xp += amount;
            
            // Check for level up
            if (state.xp >= state.xpToNextLevel) {
                state.level++;
                // Carryover XP
                const carryover = state.xp - state.xpToNextLevel;
                // New XP threshold with increasing curve (harder to level up)
                state.xpToNextLevel = Math.round(state.xpToNextLevel * 1.5);
                state.xp = carryover;
                
                // Level up bonus
                const levelBonus = state.level * 25;
                state.credits += levelBonus;
                
                showNotification(`🎮 LEVEL UP! You're now level ${state.level}! +${levelBonus} credits bonus!`);
            }
            
            saveState();
        }

        // Calculate task rarity based on importance, time and deadline proximity
        function calculateTaskRarity(importance, timeEstimate, deadline) {
            const daysRemaining = Math.max(0, (new Date(deadline) - new Date()) / (1000 * 60 * 60 * 24));
            const urgencyFactor = Math.max(1, 3 - (daysRemaining / 7)); // Higher urgency for closer deadlines
            
            // Task difficulty score (0-100)
            const difficultyScore = (importance * 15) + (timeEstimate * 5) + (urgencyFactor * 10);
            
            // Determine rarity
            if (difficultyScore >= 90) return 'legendary';
            if (difficultyScore >= 70) return 'epic';
            if (difficultyScore >= 50) return 'rare';
            if (difficultyScore >= 30) return 'uncommon';
            return 'common';
        }
        
        // Calculate credits for a task with rarity modifier
        function calculateCredits(importance, timeEstimate, deadline, rarity) {
            const daysRemaining = Math.max(0, (new Date(deadline) - new Date()) / (1000 * 60 * 60 * 24));
            const urgencyFactor = Math.max(1, 3 - (daysRemaining / 7)); // Higher urgency for closer deadlines
            
            // Base formula with some randomness for variable rewards
            const variability = 0.9 + (Math.random() * 0.2); // 90%-110% variability
            
            // Rarity multipliers
            const rarityMultipliers = {
                'common': 1,
                'uncommon': 1.5,
                'rare': 2,
                'epic': 3,
                'legendary': 5
            };
            
            // Base credits calculation
            let baseCredits = (importance * 5 + Math.log(timeEstimate + 1) * 3) * urgencyFactor * variability;
            
            // Apply rarity modifier
            baseCredits *= rarityMultipliers[rarity];
            
            // Apply anti-farming diminishing returns
            const recentCompletions = countRecentCompletions();
            if (recentCompletions > 5) {
                const diminishingFactor = Math.max(0.5, 1 - ((recentCompletions - 5) * 0.05));
                baseCredits *= diminishingFactor;
            }
            
            return Math.round(baseCredits);
        }
        
        // Count recent task completions (anti-farming)
        function countRecentCompletions() {
            const now = new Date();
            const oneDayAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
            
            return state.completionHistory.filter(timestamp => {
                return new Date(timestamp) > oneDayAgo;
            }).length;
        }

        // Roll dice for critical success chance
        function rollDice() {
            const diceContainer = document.getElementById('diceRollDisplay');
            diceContainer.innerHTML = '';
            diceContainer.classList.add('show');
            
            // Create and show dice
            const dice = document.createElement('div');
            dice.className = 'dice';
            diceContainer.appendChild(dice);
            
            // Animate dice roll
            setTimeout(() => {
                const roll = Math.floor(Math.random() * 20) + 1; // d20
                dice.textContent = roll;
                
                // Determine if critical success
                let criticalSuccess = false;
                
                // Base 5% chance (roll of 20)
                if (roll === 20) {
                    criticalSuccess = true;
                } 
                // Streak increases critical chance
                else if (roll >= (20 - Math.min(5, Math.floor(state.streak / 2)))) {
                    criticalSuccess = true;
                }
                
                dice.style.background = criticalSuccess ? 'var(--legendary)' : 'var(--primary)';
                
                return criticalSuccess;
            }, 750);
            
            // Hide dice after animation
            setTimeout(() => {
                diceContainer.classList.remove('show');
            }, 3000);
        }

        // Show celebration/notification
        function showNotification(message, type = 'success') {
            const notificationEl = document.querySelector('.reward-notification');
            notificationEl.textContent = message;
            notificationEl.style.backgroundColor = type === 'success' ? 'var(--success)' : 'var(--primary)';
            
            document.querySelector('.celebration').style.opacity = '1';
            notificationEl.style.opacity = '1';
            notificationEl.style.transform = 'translateY(0)';
            
            setTimeout(() => {
                notificationEl.style.opacity = '0';
                notificationEl.style.transform = 'translateY(20px)';
                document.querySelector('.celebration').style.opacity = '0';
            }, 3000);
        }

        // Add task
        document.getElementById('taskForm').addEventListener('submit', (e) => {
            e.preventDefault();
            
            const taskName = document.getElementById('taskName').value;
            const importance = parseInt(document.getElementById('importance').value);
            const timeEstimate = parseFloat(document.getElementById('timeEstimate').value);
            const deadline = document.getElementById('deadline').value;
            
            // Calculate task rarity
            const rarity = calculateTaskRarity(importance, timeEstimate, deadline);
            
            // Determine a suitable icon
            const icon = determineIcon(taskName);
            
            // Calculate recommended pomodoros based on time estimate
            const recommendedPomodoros = Math.max(1, Math.ceil(timeEstimate * 2)); // 2 pomodoros per hour
            
            const task = {
                name: taskName,
                timeEstimate: timeEstimate,
                importance: importance,
                deadline: deadline,
                completed: false,
                rarity: rarity,
                icon: icon,
                credits: calculateCredits(importance, timeEstimate, deadline, rarity),
                xp: Math.round(importance * 10 + timeEstimate * 5), // Base XP
                created: new Date().toISOString(),
                subtasks: [],
                pomodoroStats: {
                    completed: 0,
                    total: recommendedPomodoros,
                    lootBonusPercent: 0
                }
            };
            
            state.tasks.push(task);
            saveState();
            updateUI();
            e.target.reset();
            
            showNotification(`New ${rarity} quest added: ${task.name}!`, 'primary');
        });

        // Add wishlist item with psychology-based credit formula
        document.getElementById('wishlistForm').addEventListener('submit', (e) => {
            e.preventDefault();
            
            const itemName = document.getElementById('itemName').value;
            const cost = parseFloat(document.getElementById('itemCost').value);
            const timeline = parseInt(document.getElementById('timeline').value);
            const desireLevel = parseInt(document.getElementById('desireLevel').value);
            
            // Determine a suitable icon
            const icon = determineIcon(itemName);
            
            // Base multiplier with variability
            const baseMultiplier = 9 + Math.random() * 2;
            
            // Progressive difficulty
            const difficultyMultiplier = state.wishlist.length === 0 ? 
                                        0.8 : // First item easier
                                        1 + (state.wishlist.length * 0.05); // Gets progressively harder
            
            // Timeline factor (longer timeline = more credits)
            const timelineFactor = 1 + (timeline / 20);
            
            // Desire discount (higher desire = slightly fewer credits)
            const desireMultiplier = 1.2 - (desireLevel * 0.08);
            
            // Calculate final credits
            const totalCredits = Math.round(cost * baseMultiplier * difficultyMultiplier * 
                                timelineFactor * desireMultiplier);
            
            // Endowed progress (small head start)
            const headStart = Math.min(0.05 * totalCredits, 50);
            
            const item = {
                name: itemName,
                icon: icon,
                cost: cost,
                timeline: timeline,
                desireLevel: desireLevel,
                credits: totalCredits,
                progress: headStart,
                displayProgress: headStart / totalCredits,
                milestones: [0.25, 0.5, 0.75, 1], // Progress milestones at 25%, 50%, 75%, 100%
                created: new Date().toISOString()
            };
            
            // Apply the head start if user has enough credits
            if (state.credits >= headStart) {
                state.credits -= headStart;
                showNotification(`Got a head start on "${item.name}"!`, 'primary');
            } else {
                item.progress = state.credits;
                item.displayProgress = state.credits / totalCredits;
                state.credits = 0;
            }
            
            // Create a unique ID for this item
            item.id = Date.now().toString();
            
            // Initialize milestones tracking
            state.milestones[item.id] = [];
            
            state.wishlist.push(item);
            saveState();
            updateUI();
            e.target.reset();
            
            showNotification(`New reward added: ${item.name}`, 'primary');
        });

        // Open Pomodoro modal for a task
        function startPomodoro(index) {
            const task = state.tasks[index];
            
            // Set up the pomodoro modal
            document.getElementById('pomodoroTaskName').textContent = task.name;
            document.getElementById('phaseType').textContent = 'Focus Time';
            document.getElementById('phaseType').className = 'focus-time';
            document.getElementById('timerDisplay').textContent = '25:00';
            
            // Reset buttons
            document.getElementById('startTimer').disabled = false;
            document.getElementById('pauseTimer').disabled = true;
            
            // Set up pomodoro progress visualization
            const progressContainer = document.getElementById('pomodoroProgress');
            progressContainer.innerHTML = '';
            
            // Add segments for total pomodoros
            for (let i = 0; i < task.pomodoroStats.total; i++) {
                const segment = document.createElement('div');
                segment.className = 'pomodoro-segment';
                if (i < task.pomodoroStats.completed) {
                    segment.classList.add('completed');
                }
                progressContainer.appendChild(segment);
            }
            
            // Update stats display
            document.getElementById('completedPomodoros').textContent = task.pomodoroStats.completed;
            document.getElementById('totalPomodoros').textContent = task.pomodoroStats.total;
            document.getElementById('lootBonus').textContent = task.pomodoroStats.lootBonusPercent;
            
            // Load subtasks
            loadSubtasks(task);
            
            // Store task index
            state.activePomodoro = {
                taskIndex: index,
                phase: 'focus',
                timeRemaining: 25 * 60, // 25 minutes in seconds
                running: false,
                currentPomodoro: task.pomodoroStats.completed,
                startTime: null,
                lastActive: new Date().getTime()
            };
            
            saveState();
            
            // Show the modal
            document.getElementById('pomodoroModal').classList.add('show');
        }
        
        // Load subtasks for a task
        function loadSubtasks(task) {
            const subtasksContainer = document.getElementById('subtasksContainer');
            subtasksContainer.innerHTML = '';
            
            if (task.subtasks && task.subtasks.length > 0) {
                task.subtasks.forEach((subtask, index) => {
                    const subtaskElement = document.createElement('div');
                    subtaskElement.className = 'subtask-item';
                    if (subtask.completed) {
                        subtaskElement.classList.add('subtask-completed');
                    }
                    
                    subtaskElement.innerHTML = `
                        <span>${subtask.name}</span>
                        <div>
                            ${!subtask.completed ? 
                                `<button onclick="completeSubtask(${index})">Complete</button>` : 
                                `<span style="color: var(--success)">✓</span>`
                            }
                        </div>
                    `;
                    
                    subtasksContainer.appendChild(subtaskElement);
                });
            } else {
                subtasksContainer.innerHTML = `<p>No subtasks yet. Add some to break down this quest!</p>`;
            }
        }
        
        // Add a subtask to the current active task
        function addSubtask() {
            const subtaskInput = document.getElementById('subtaskInput');
            const subtaskName = subtaskInput.value.trim();
            
            if (subtaskName && state.activePomodoro) {
                const taskIndex = state.activePomodoro.taskIndex;
                const task = state.tasks[taskIndex];
                
                task.subtasks.push({
                    name: subtaskName,
                    completed: false,
                    created: new Date().toISOString()
                });
                
                saveState();
                loadSubtasks(task);
                subtaskInput.value = '';
            }
        }
        
        // Complete a subtask
        function completeSubtask(subtaskIndex) {
            if (state.activePomodoro) {
                const taskIndex = state.activePomodoro.taskIndex;
                const task = state.tasks[taskIndex];
                
                if (task.subtasks[subtaskIndex]) {
                    task.subtasks[subtaskIndex].completed = true;
                    
                    // Award a small XP bonus for completing subtasks
                    addXP(5);
                    
                    saveState();
                    loadSubtasks(task);
                    
                    showNotification(`Subtask completed! +5 XP`);
                }
            }
        }
        
        // Start Pomodoro timer
        function startPomodoroTimer() {
            if (!state.activePomodoro) return;
            
            // Update UI
            document.getElementById('startTimer').disabled = true;
            document.getElementById('pauseTimer').disabled = false;
            
            // Set start time if not already running
            if (!state.activePomodoro.startTime) {
                state.activePomodoro.startTime = new Date().getTime();
            }
            
            state.activePomodoro.running = true;
            saveState();
            
            // Start timer update interval
            updatePomodoroTimer();
        }
        
        // Update Pomodoro timer
        function updatePomodoroTimer() {
            if (!state.activePomodoro || !state.activePomodoro.running) return;
            
            const now = new Date().getTime();
            const elapsed = Math.floor((now - state.activePomodoro.startTime) / 1000);
            state.activePomodoro.timeRemaining = Math.max(0, (state.activePomodoro.phase === 'focus' ? 25 * 60 : 5 * 60) - elapsed);
            state.activePomodoro.lastActive = now;
            
            // Update display
            const minutes = Math.floor(state.activePomodoro.timeRemaining / 60);
            const seconds = state.activePomodoro.timeRemaining % 60;
            document.getElementById('timerDisplay').textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Mark current segment as active
            const segments = document.querySelectorAll('.pomodoro-segment');
            if (segments.length > state.activePomodoro.currentPomodoro) {
                // Remove current class from all segments
                segments.forEach(seg => seg.classList.remove('current'));
                // Add current class to active segment
                if (state.activePomodoro.phase === 'focus') {
                    segments[state.activePomodoro.currentPomodoro].classList.add('current');
                }
            }
            
            // Check if timer is complete
            if (state.activePomodoro.timeRemaining <= 0) {
                handlePomodoroComplete();
            } else {
                // Continue timer
                saveState();
                setTimeout(updatePomodoroTimer, 1000);
            }
        }
        
        // Handle Pomodoro completion
        function handlePomodoroComplete() {
            const taskIndex = state.activePomodoro.taskIndex;
            const task = state.tasks[taskIndex];
            
            if (state.activePomodoro.phase === 'focus') {
                // Completed a focus session
                task.pomodoroStats.completed++;
                
                // Calculate loot bonus (each completed pomodoro increases chance)
                task.pomodoroStats.lootBonusPercent = Math.min(50, task.pomodoroStats.completed * 5);
                
                // Award XP for completing a pomodoro
                addXP(10);
                
                // Update UI
                document.getElementById('completedPomodoros').textContent = task.pomodoroStats.completed;
                document.getElementById('lootBonus').textContent = task.pomodoroStats.lootBonusPercent;
                
                // Mark segment as completed
                const segments = document.querySelectorAll('.pomodoro-segment');
                if (segments.length > state.activePomodoro.currentPomodoro) {
                    segments[state.activePomodoro.currentPomodoro].classList.add('completed');
                    segments[state.activePomodoro.currentPomodoro].classList.remove('current');
                }
                
                // Show notification
                showNotification(`Pomodoro completed! +10 XP, Loot bonus now ${task.pomodoroStats.lootBonusPercent}%`);
                
                // Switch to break phase
                state.activePomodoro.phase = 'rest';
                state.activePomodoro.timeRemaining = 5 * 60; // 5 minute break
                state.activePomodoro.startTime = new Date().getTime();
                state.activePomodoro.currentPomodoro++;
                
                // Update phase display
                document.getElementById('phaseType').textContent = 'Rest Time';
                document.getElementById('phaseType').className = 'rest-time';
                
            } else {
                // Completed a rest phase
                // Switch back to focus phase
                state.activePomodoro.phase = 'focus';
                state.activePomodoro.timeRemaining = 25 * 60; // 25 minute focus
                state.activePomodoro.startTime = new Date().getTime();
                
                // Update phase display
                document.getElementById('phaseType').textContent = 'Focus Time';
                document.getElementById('phaseType').className = 'focus-time';
                
                showNotification(`Break complete! Ready for next focus session.`);
            }
            
            saveState();
            
            // Auto-continue timer
            updatePomodoroTimer();
        }
        
        // Pause Pomodoro timer
        function pausePomodoroTimer() {
            if (!state.activePomodoro) return;
            
            state.activePomodoro.running = false;
            saveState();
            
            // Update UI
            document.getElementById('startTimer').disabled = false;
            document.getElementById('pauseTimer').disabled = true;
        }
        
        // Skip current Pomodoro phase
        function skipPomodoroPhase() {
            if (!state.activePomodoro) return;
            
            // If skipping focus phase, don't count it as completed
            if (state.activePomodoro.phase === 'focus') {
                state.activePomodoro.phase = 'rest';
                state.activePomodoro.timeRemaining = 5 * 60; // 5 minute break
                state.activePomodoro.startTime = new Date().getTime();
                
                // Update phase display
                document.getElementById('phaseType').textContent = 'Rest Time';
                document.getElementById('phaseType').className = 'rest-time';
            } else {
                // Skipping break phase
                state.activePomodoro.phase = 'focus';
                state.activePomodoro.timeRemaining = 25 * 60; // 25 minute focus
                state.activePomodoro.startTime = new Date().getTime();
                
                // Update phase display
                document.getElementById('phaseType').textContent = 'Focus Time';
                document.getElementById('phaseType').className = 'focus-time';
            }
            
            saveState();
            
            // If timer is running, continue updating
            if (state.activePomodoro.running) {
                updatePomodoroTimer();
            }
        }
        
        // Close Pomodoro modal
        function closePomodoroModal() {
            document.getElementById('pomodoroModal').classList.remove('show');
            
            // Pause timer if running
            if (state.activePomodoro && state.activePomodoro.running) {
                pausePomodoroTimer();
            }
            
            // Keep the activePomodoro data for resuming later
            saveState();
            updateUI();
        }

        // Complete task with chance for critical success and pomodoro bonus
        function completeTask(index) {
            const task = state.tasks[index];
            if (!task.completed) {
                // Log completion time to history (for anti-farming)
                state.completionHistory.push(new Date().toISOString());
                
                // Roll dice for critical success
                const diceContainer = document.getElementById('diceRollDisplay');
                diceContainer.innerHTML = '';
                diceContainer.classList.add('show');
                
                // Create and show dice
                const dice = document.createElement('div');
                dice.className = 'dice';
                diceContainer.appendChild(dice);
                
                // Mark as completed first to prevent double-clicks
                task.completed = true;
                
                // Adjust completion UI
                const taskElements = document.querySelectorAll('.task-list li');
                if (taskElements[index]) {
                    const completeBtn = taskElements[index].querySelector('.complete-btn');
                    if (completeBtn) {
                        completeBtn.disabled = true;
                        completeBtn.textContent = 'Rolling...';
                    }
                }
                
                // Animate dice roll
                setTimeout(() => {
                    // Roll the dice
                    const roll = Math.floor(Math.random() * 20) + 1; // d20
                    dice.textContent = roll;
                    
                    // Determine if critical success with pomodoro bonus
                    let criticalSuccess = false;
                    let criticalFail = false;
                    
                    // Pomodoro bonus increases critical chance
                    const pomodoroBonus = task.pomodoroStats ? task.pomodoroStats.lootBonusPercent / 100 : 0;
                    
                    // Base critical chance
                    if (roll === 20) {
                        criticalSuccess = true;
                    } 
                    // Streak + Pomodoro increases critical chance
                    else if (roll >= (20 - Math.min(5, Math.floor(state.streak / 2)) - Math.floor(pomodoroBonus * 10))) {
                        criticalSuccess = true;
                    }
                    // Very small chance of critical fail
                    else if (roll === 1) {
                        criticalFail = true;
                    }
                    
                    // Apply streak bonus
                    let bonus = 1 + (state.streak * 0.1);
                    
                    // Apply early completion bonus
                    const daysEarly = Math.max(0, (new Date(task.deadline) - new Date()) / (1000 * 60 * 60 * 24));
                    const earlyBonus = daysEarly * 0.05;
                    bonus += earlyBonus;
                    
                    // Apply pomodoro bonus
                    if (pomodoroBonus > 0) {
                        bonus += pomodoroBonus;
                    }
                    
                    // Rarity multipliers for more variance
                    const rarityMultipliers = {
                        'common': 1,
                        'uncommon': 1.2,
                        'rare': 1.5,
                        'epic': 2,
                        'legendary': 3
                    };
                    
                    // Base credits calculation
                    let creditsEarned = Math.round(task.credits * bonus * rarityMultipliers[task.rarity]);
                    let xpEarned = task.xp;
                    
                    if (criticalSuccess) {
                        // Critical success - double rewards!
                        creditsEarned = Math.round(creditsEarned * 2);
                        xpEarned = Math.round(xpEarned * 2);
                        dice.style.background = 'var(--legendary)';
                        dice.style.boxShadow = '0 0 10px var(--legendary)';
                    } else if (criticalFail) {
                        // Critical fail - half rewards
                        creditsEarned = Math.round(creditsEarned * 0.5);
                        xpEarned = Math.round(xpEarned * 0.5);
                        dice.style.background = 'var(--danger)';
                    } else {
                        dice.style.background = 'var(--primary)';
                    }
                    
                    // Update player stats
                    state.credits += creditsEarned;
                    state.streak++;
                    state.lastStreak = new Date().toDateString();
                    addXP(xpEarned);
                    
                    // If this was the active pomodoro task, clear it
                    if (state.activePomodoro && state.activePomodoro.taskIndex === index) {
                        state.activePomodoro = null;
                    }
                    
                    // Show the result message
                    let message = '';
                    if (criticalSuccess) {
                        message = `🌟 CRITICAL SUCCESS! +${creditsEarned} credits, +${xpEarned} XP`;
                    } else if (criticalFail) {
                        message = `😓 Critical fail... +${creditsEarned} credits, +${xpEarned} XP`;
                    } else {
                        message = `Quest completed! +${creditsEarned} credits, +${xpEarned} XP`;
                        if (state.streak > 1) {
                            message += ` (${state.streak}x streak bonus!)`;
                        }
                        if (earlyBonus > 0) {
                            message += ` (Early completion bonus!)`;
                        }
                        if (pomodoroBonus > 0) {
                            message += ` (Pomodoro bonus: ${Math.round(pomodoroBonus * 100)}%!)`;
                        }
                    }
                    
                    // Chance for bonus loot for higher rarity tasks (Easter egg)
                    if (['rare', 'epic', 'legendary'].includes(task.rarity) && Math.random() < 0.3) {
                        const bonusCredits = Math.round(task.credits * 0.2);
                        state.credits += bonusCredits;
                        message += ` BONUS LOOT: +${bonusCredits} credits!`;
                    }
                    
                    // Additional chance for bonus with pomodoro sessions
                    if (task.pomodoroStats && task.pomodoroStats.completed > 0 && Math.random() < pomodoroBonus) {
                        const pomodoroBonus = Math.round(task.credits * 0.3);
                        state.credits += pomodoroBonus;
                        message += ` POMODORO CHEST: +${pomodoroBonus} credits!`;
                    }
                    
                    // Show notification after roll
                    setTimeout(() => {
                        showNotification(message);
                    }, 500);
                    
                    saveState();
                    updateWishlistProgress();
                    updateUI();
                }, 750);
                
                // Hide dice after animation
                setTimeout(() => {
                    diceContainer.classList.remove('show');
                }, 3000);
            }
        }
        
        // Abandon task (with penalty)
        function abandonTask(index) {
            const task = state.tasks[index];
            if (!task.completed) {
                // Apply penalty
                const penalty = Math.round(task.credits * 0.25);
                state.credits = Math.max(0, state.credits - penalty);
                
                // Reset streak
                state.streak = 0;
                
                // Show notification
                showNotification(`Quest abandoned! -${penalty} credits. Streak reset!`, 'danger');
                
                // If this was the active pomodoro task, clear it
                if (state.activePomodoro && state.activePomodoro.taskIndex === index) {
                    state.activePomodoro = null;
                }
                
                // Remove task
                state.tasks.splice(index, 1);
                
                saveState();
                updateUI();
            }
        }

        // Update wishlist progress with psychological enhancements
        function updateWishlistProgress() {
            state.wishlist.forEach(item => {
                // Store previous progress for milestone checking
                const previousProgress = item.progress / item.credits;
                
                // Base progress as a proportion of total credits needed
                let baseProgress = Math.min(state.credits, item.credits - item.progress);
                
                // Goal-gradient effect - acceleration in final stretch
                if ((item.progress / item.credits) > 0.7 && (item.progress / item.credits) < 1) {
                    const goalGradientBonus = baseProgress * 0.1; // 10% bonus in final stretch
                    baseProgress += goalGradientBonus;
                }
                
                // Check if the user can allocate credits to this item
                if (baseProgress > 0) {
                    // Update item progress
                    item.progress += baseProgress;
                    state.credits -= baseProgress;
                    
                    // Update display progress with visual enhancement
                    item.displayProgress = Math.min(1, item.progress / item.credits);
                    
                    // Check for milestones
                    item.milestones.forEach(milestone => {
                        if (previousProgress < milestone && item.displayProgress >= milestone) {
                            if (!state.milestones[item.id] || !state.milestones[item.id].includes(milestone)) {
                                if (!state.milestones[item.id]) state.milestones[item.id] = [];
                                state.milestones[item.id].push(milestone);
                                
                                const percentComplete = Math.round(milestone * 100);
                                showNotification(`${percentComplete}% progress on "${item.name}"!`);
                                
                                // Add XP for milestone
                                if (milestone < 1) {
                                    addXP(Math.round(milestone * 50));
                                }
                            }
                        }
                    });
                    
                    // Check if item is now complete
                    if (item.displayProgress >= 1 && (!state.milestones[item.id] || !state.milestones[item.id].includes('completed'))) {
                        if (!state.milestones[item.id]) state.milestones[item.id] = [];
                        state.milestones[item.id].push('completed');
                        showNotification(`🎉 Reward unlocked: "${item.name}"! 🎉`);
                        
                        // Bonus XP for completion
                        addXP(100);
                    }
                }
            });
            
            saveState();
        }

        // Update UI
        function updateUI() {
            // Update credits and level display
            document.getElementById('totalCredits').textContent = state.credits;
            document.getElementById('currentStreak').textContent = state.streak;
            document.getElementById('playerLevel').textContent = state.level;
            document.getElementById('currentXP').textContent = state.xp;
            document.getElementById('xpToNextLevel').textContent = state.xpToNextLevel;
            document.getElementById('levelProgress').style.width = `${(state.xp / state.xpToNextLevel) * 100}%`;

            // Update tasks list
            const taskList = document.getElementById('taskList');
            taskList.innerHTML = state.tasks
                .filter(task => !task.completed) // Show only uncompleted tasks
                .map((task, index) => {
                    const actualIndex = state.tasks.indexOf(task);
                    
                    // Format deadline with urgency coloring
                    const today = new Date();
                    const deadline = new Date(task.deadline);
                    const daysRemaining = Math.floor((deadline - today) / (1000 * 60 * 60 * 24));
                    
                    let deadlineClass = '';
                    if (daysRemaining < 0) {
                        deadlineClass = 'style="color: var(--danger); font-weight: bold;"';
                    } else if (daysRemaining < 2) {
                        deadlineClass = 'style="color: var(--warning); font-weight: bold;"';
                    }
                    
                    // Determine streak bonus
                    const streakBonus = Math.round(task.credits * state.streak * 0.1);
                    
                    // Get rarity name with proper capitalization
                    const rarityName = task.rarity.charAt(0).toUpperCase() + task.rarity.slice(1);
                    
                    // Show pomodoro progress if applicable
                    let pomodoroProgress = '';
                    if (task.pomodoroStats && task.pomodoroStats.total > 0) {
                        const percent = Math.round((task.pomodoroStats.completed / task.pomodoroStats.total) * 100);
                        pomodoroProgress = `
                            <div style="margin-top: 0.5rem;">
                                <span style="font-size: 0.8rem;">Pomodoros: ${task.pomodoroStats.completed}/${task.pomodoroStats.total} (${percent}%)</span>
                                <div class="progress-bar" style="height: 0.5rem;">
                                    <div class="progress-bar-fill" style="width: ${percent}%; background: var(--focus);"></div>
                                </div>
                            </div>
                        `;
                    }
                    
                    // Show subtasks if any
                    let subtasksHTML = '';
                    if (task.subtasks && task.subtasks.length > 0) {
                        const completedSubtasks = task.subtasks.filter(st => st.completed).length;
                        const subtaskPercent = Math.round((completedSubtasks / task.subtasks.length) * 100);
                        
                        subtasksHTML = `
                            <div style="margin-top: 0.5rem;">
                                <span style="font-size: 0.8rem;">Subtasks: ${completedSubtasks}/${task.subtasks.length} (${subtaskPercent}%)</span>
                                <div class="progress-bar" style="height: 0.5rem;">
                                    <div class="progress-bar-fill" style="width: ${subtaskPercent}%;"></div>
                                </div>
                            </div>
                        `;
                    }
                    
                    return `
                    <li class="${task.rarity}">
                        <div class="task-info">
                            <div class="task-header">
                                <div class="quest-icon">${task.icon}</div>
                                <strong>${task.name}</strong> <span style="font-size: 0.8em; color: var(--${task.rarity === 'common' ? 'secondary' : task.rarity});">[${rarityName}]</span>
                            </div>
                            <div style="margin-top: 0.5rem;">
                                ${task.importance}★ | ${task.timeEstimate}h | Due: <span ${deadlineClass}>${task.deadline}</span><br>
                                Reward: ${task.credits} credits (+${streakBonus} streak bonus), ${task.xp} XP
                                <div class="tooltip">ⓘ
                                    <span class="tooltiptext">
                                        Critical success chance: ${5 + Math.min(5, Math.floor(state.streak / 2))}%<br>
                                        Pomodoro bonus: +${task.pomodoroStats ? task.pomodoroStats.lootBonusPercent : 0}%<br>
                                        Total critical chance: ${5 + Math.min(5, Math.floor(state.streak / 2)) + (task.pomodoroStats ? task.pomodoroStats.lootBonusPercent : 0)}%
                                    </span>
                                </div>
                            </div>
                            ${pomodoroProgress}
                            ${subtasksHTML}
                        </div>
                        <div class="task-buttons">
                            <button onclick="startPomodoro(${actualIndex})" class="pomodoro-btn">Pomodoro</button>
                            <button onclick="completeTask(${actualIndex})" class="complete-btn">Complete</button>
                            <button onclick="abandonTask(${actualIndex})" class="abandon-btn">Abandon</button>
                        </div>
                    </li>
                `})
                .join('');

            // Add completed tasks at the bottom (show only most recent 5)
            const completedTasks = state.tasks
                .filter(task => task.completed)
                .sort((a, b) => new Date(b.completed) - new Date(a.completed))
                .slice(0, 5)
                .map((task) => `
                    <li style="opacity: 0.7;" class="${task.rarity}">
                        <div>
                            <div class="task-header">
                                <div class="quest-icon">${task.icon}</div>
                                <strong>${task.name}</strong> <span style="font-size: 0.8em; color: var(--${task.rarity === 'common' ? 'secondary' : task.rarity});">[${task.rarity.charAt(0).toUpperCase() + task.rarity.slice(1)}]</span>
                            </div>
                            ${task.importance}★ | ${task.timeEstimate}h | Completed
                        </div>
                        <span style="color: var(--success)">✓ Done</span>
                    </li>
                `)
                .join('');
                
            if (completedTasks) {
                taskList.innerHTML += `<h4>Completed quests</h4>${completedTasks}`;
            }

            // Update wishlist with enhanced progress display
            const wishlist = document.getElementById('wishlist');
            wishlist.innerHTML = state.wishlist
                .map((item, index) => {
                    // Build milestone markers
                    const milestonesHTML = item.milestones
                        .map(milestone => `
                            <div class="milestone" style="left: ${milestone * 100}%;"></div>
                        `)
                        .join('');
                    
                    // Calculate progress and display progress
                    const progressPercent = (item.progress / item.credits) * 100;
                    const displayProgressPercent = item.displayProgress * 100;
                    
                    // Check if item is complete
                    const isComplete = displayProgressPercent >= 100;
                    
                    return `
                    <li>
                        <div style="width: 100%;">
                            <div class="reward-header">
                                <div class="reward-icon">${item.icon}</div>
                                <strong>${item.name}</strong> ${isComplete ? '✅' : ''}
                            </div>
                            <div style="margin-top: 0.5rem;">
                                ${item.cost} HKD | ${item.timeline} weeks | Desire: ${item.desireLevel}/5
                                <br>
                                ${Math.round(progressPercent)}% complete | ${Math.round(item.progress)}/${item.credits} credits
                            </div>
                            <div class="progress-bar" style="position: relative;">
                                ${milestonesHTML}
                                <div class="progress-bar-fill" style="width: ${Math.min(100, displayProgressPercent)}%"></div>
                            </div>
                        </div>
                    </li>
                `})
                .join('');
        }

        // Initialize
        loadState();

        // Daily credit decay (check on page load)
        const lastDecay = localStorage.getItem('lastCreditDecay');
        const now = new Date().toDateString();
        if (lastDecay !== now) {
            // Apply a small decay to maintain engagement
            state.credits = Math.max(0, Math.round(state.credits * 0.98));
            localStorage.setItem('lastCreditDecay', now);
            saveState();
        }

        // Auto-update wishlist progress when page loads
        updateWishlistProgress();
        updateUI();
    </script>
</body>
</html>
