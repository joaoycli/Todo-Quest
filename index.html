<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest Todo - Productivity RPG</title>
    <style>
        :root {
            --primary: #4f46e5;
            --secondary: #818cf8;
            --success: #22c55e;
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #0ea5e9;
            --rare: #9333ea;
            --epic: #c026d3;
            --legendary: #fbbf24;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f3f4f6;
            color: #1f2937;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .stats {
            display: flex;
            gap: 1rem;
        }

        .credits {
            background: var(--primary);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }

        .streak {
            background: var(--warning);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }

        .level {
            background: var(--info);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .card {
            background: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .card h2 {
            margin-top: 0;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 0.5rem;
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(1px);
        }

        input, select {
            width: 100%;
            padding: 0.5rem;
            margin-bottom: 1rem;
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
        }

        .task-list, .wishlist {
            list-style: none;
            padding: 0;
        }

        .task-list li, .wishlist li {
            background: #f9fafb;
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .task-list li:hover, .wishlist li:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }

        .common {
            border-left: 4px solid #9ca3af;
        }

        .uncommon {
            border-left: 4px solid var(--success);
        }

        .rare {
            border-left: 4px solid var(--rare);
        }

        .epic {
            border-left: 4px solid var(--epic);
        }

        .legendary {
            border-left: 4px solid var(--legendary);
            background: linear-gradient(to right, #fef3c7, #f9fafb 30%);
        }

        .progress-bar {
            background: #e5e7eb;
            height: 1rem;
            border-radius: 0.5rem;
            overflow: hidden;
            margin-top: 0.5rem;
            position: relative;
        }

        .progress-bar-fill {
            background: var(--success);
            height: 100%;
            transition: width 0.3s ease;
        }

        .milestone {
            position: absolute;
            height: 100%;
            width: 2px;
            background: var(--warning);
        }

        .tooltip {
            position: relative;
            display: inline-block;
            margin-left: 0.5rem;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .reward-notification {
            background: var(--primary);
            color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-size: 1.25rem;
            font-weight: bold;
            transition: transform 0.5s, opacity 0.5s;
            transform: translateY(20px);
            opacity: 0;
        }

        .dice-roll {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 1rem 0;
            gap: 1rem;
            height: 0;
            overflow: hidden;
            transition: height 0.3s ease;
        }

        .dice-roll.show {
            height: 60px;
        }

        .dice {
            width: 50px;
            height: 50px;
            background: var(--primary);
            color: white;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            animation: roll 0.75s ease-out;
        }

        @keyframes roll {
            0% { transform: rotateZ(0deg); }
            100% { transform: rotateZ(720deg); }
        }

        .bonus-card {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            z-index: 1001;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s ease;
            max-width: 90%;
            width: 400px;
        }

        .bonus-card.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: all;
        }

        .bonus-card-options {
            display: flex;
            justify-content: space-around;
            margin-top: 2rem;
        }

        .bonus-option {
            padding: 1rem;
            border-radius: 0.5rem;
            background: #f9fafb;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            margin: 0 0.5rem;
            border: 2px solid transparent;
        }

        .bonus-option:hover {
            transform: translateY(-2px);
            border-color: var(--primary);
        }

        .level-bar {
            background: #e5e7eb;
            height: 0.5rem;
            border-radius: 0.25rem;
            overflow: hidden;
            margin-top: 0.5rem;
            width: 100px;
        }

        .level-bar-fill {
            background: var(--info);
            height: 100%;
            transition: width 0.3s ease;
        }

        .level-container {
            display: flex;
            align-items: center;
        }

        .loot-table {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .loot-item {
            background: #f9fafb;
            padding: 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .rarity-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .task-buttons {
            display: flex;
            gap: 0.5rem;
        }

        .task-info {
            flex: 1;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .task-list li {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .task-buttons {
                width: 100%;
                margin-top: 1rem;
                justify-content: flex-end;
            }
        }
    </style>
</head>
<body>
    <div class="celebration">
        <div class="reward-notification"></div>
    </div>
    
    <div class="bonus-card">
        <h2>Bonus Challenge!</h2>
        <p>Choose your reward path:</p>
        <div class="bonus-card-options">
            <div class="bonus-option" onclick="selectBonusOption('safe')">
                <h3>Safe</h3>
                <p>Guaranteed <span id="safeAmount">20</span> credits</p>
            </div>
            <div class="bonus-option" onclick="selectBonusOption('risky')">
                <h3>Risky</h3>
                <p>50% chance of <span id="riskyAmount">40</span> credits</p>
            </div>
            <div class="bonus-option" onclick="selectBonusOption('epic')">
                <h3>Epic</h3>
                <p>20% chance of <span id="epicAmount">100</span> credits</p>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="header">
            <h1>Quest Todo</h1>
            <div class="stats">
                <div class="level-container">
                    <div class="level">Level <span id="playerLevel">1</span></div>
                    <div style="margin-left: 0.5rem;">
                        <div class="level-bar">
                            <div class="level-bar-fill" id="levelProgress" style="width: 0%"></div>
                        </div>
                        <div style="font-size: 0.75rem; text-align: center;"><span id="currentXP">0</span>/<span id="xpToNextLevel">100</span> XP</div>
                    </div>
                </div>
                <div class="streak">Streak: <span id="currentStreak">0</span> days</div>
                <div class="credits">Credits: <span id="totalCredits">0</span></div>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>Add Quest</h2>
                <form id="taskForm">
                    <input type="text" id="taskName" placeholder="Quest name" required="">
                    <input type="number" id="timeEstimate" placeholder="Time estimate (hours)" required="" min="0" step="0.5">
                    <select id="importance" required="">
                        <option value="">Select difficulty</option>
                        <option value="1">Easy â˜…</option>
                        <option value="2">Normal â˜…â˜…</option>
                        <option value="3">Hard â˜…â˜…â˜…</option>
                        <option value="4">Very Hard â˜…â˜…â˜…â˜…</option>
                        <option value="5">Epic â˜…â˜…â˜…â˜…â˜…</option>
                    </select>
                    <input type="date" id="deadline" required="">
                    <button type="submit">Create Quest</button>
                </form>
                
                <div class="dice-roll" id="diceRollDisplay">
                    <!-- Dice will be injected here when rolling -->
                </div>
                
                <div style="margin-top: 1rem;">
                    <h3>Loot Table</h3>
                    <div class="loot-table">
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: #9ca3af;"></div>
                            Common (60%)
                        </div>
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: var(--success);"></div>
                            Uncommon (25%)
                        </div>
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: var(--rare);"></div>
                            Rare (10%)
                        </div>
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: var(--epic);"></div>
                            Epic (4%)
                        </div>
                        <div class="loot-item">
                            <div class="rarity-dot" style="background: var(--legendary);"></div>
                            Legendary (1%)
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>Add Reward</h2>
                <form id="wishlistForm">
                    <input type="text" id="itemName" placeholder="Reward name" required="">
                    <input type="number" id="itemCost" placeholder="Cost (HKD)" required="" min="0">
                    <input type="number" id="timeline" placeholder="Timeline (weeks)" required="" min="1">
                    <select id="desireLevel" required="">
                        <option value="">How much do you want this?</option>
                        <option value="1">Nice to have</option>
                        <option value="2">Want it</option>
                        <option value="3">Really want it</option>
                        <option value="4">Desperately want it</option>
                        <option value="5">Must have it!</option>
                    </select>
                    <button type="submit">Add Reward</button>
                </form>
            </div>
        </div>

        <div class="grid">
            <div class="card">
                <h2>Active Quests</h2>
                <ul id="taskList" class="task-list"></ul>
            </div>

            <div class="card">
                <h2>Rewards</h2>
                <ul id="wishlist" class="wishlist"></ul>
            </div>
        </div>
    </div>

    <script>
        // State management
        let state = {
            tasks: [],
            wishlist: [],
            credits: 0,
            streak: 0,
            lastStreak: new Date().toDateString(),
            notifications: [],
            milestones: {},
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            lastDaily: null,
            bonusChallenge: null,
            completionHistory: []
        };

        // Load state from localStorage
        function loadState() {
            const savedState = localStorage.getItem('questTodoState');
            if (savedState) {
                state = JSON.parse(savedState);
                
                // Backward compatibility
                if (!state.level) state.level = 1;
                if (!state.xp) state.xp = 0;
                if (!state.xpToNextLevel) state.xpToNextLevel = 100;
                if (!state.completionHistory) state.completionHistory = [];
                
                // Check if streak should continue or reset
                const today = new Date().toDateString();
                const lastStreakDate = new Date(state.lastStreak);
                const dayDiff = Math.floor((new Date() - lastStreakDate) / (1000 * 60 * 60 * 24));
                
                if (dayDiff > 1) {
                    // Reset streak if more than a day has passed
                    state.streak = 0;
                }
                
                // Check for daily bonus challenge
                checkDailyChallenge();
                
                updateUI();
            }
        }

        // Save state to localStorage
        function saveState() {
            localStorage.setItem('questTodoState', JSON.stringify(state));
        }

        // Check for daily bonus challenge
        function checkDailyChallenge() {
            const today = new Date().toDateString();
            if (state.lastDaily !== today) {
                // 30% chance of bonus challenge
                if (Math.random() < 0.3) {
                    // Create bonus challenge
                    const baseAmount = 20 + (state.level * 5);
                    state.bonusChallenge = {
                        safeAmount: baseAmount,
                        riskyAmount: Math.round(baseAmount * 2),
                        epicAmount: Math.round(baseAmount * 5),
                        day: today
                    };
                    
                    // Update the UI with the amounts
                    document.getElementById('safeAmount').textContent = state.bonusChallenge.safeAmount;
                    document.getElementById('riskyAmount').textContent = state.bonusChallenge.riskyAmount;
                    document.getElementById('epicAmount').textContent = state.bonusChallenge.epicAmount;
                    
                    // Show the bonus challenge
                    setTimeout(() => {
                        document.querySelector('.bonus-card').classList.add('show');
                    }, 1000);
                }
                state.lastDaily = today;
                saveState();
            }
        }
        
        // Select bonus option
        function selectBonusOption(option) {
            let amount = 0;
            let message = '';
            
            switch(option) {
                case 'safe':
                    amount = state.bonusChallenge.safeAmount;
                    message = `Safe choice! +${amount} credits`;
                    break;
                case 'risky':
                    if (Math.random() < 0.5) {
                        amount = state.bonusChallenge.riskyAmount;
                        message = `Risky paid off! +${amount} credits`;
                    } else {
                        message = 'Took a risk but no reward this time!';
                    }
                    break;
                case 'epic':
                    if (Math.random() < 0.2) {
                        amount = state.bonusChallenge.epicAmount;
                        message = `EPIC WIN! +${amount} credits`;
                    } else {
                        message = 'Went for epic... but no luck today!';
                    }
                    break;
            }
            
            if (amount > 0) {
                state.credits += amount;
                addXP(Math.round(amount / 2));
            }
            
            document.querySelector('.bonus-card').classList.remove('show');
            showNotification(message);
            
            state.bonusChallenge = null;
            saveState();
            updateUI();
        }
        
        // Add XP and handle leveling up
        function addXP(amount) {
            state.xp += amount;
            
            // Check for level up
            if (state.xp >= state.xpToNextLevel) {
                state.level++;
                // Carryover XP
                const carryover = state.xp - state.xpToNextLevel;
                // New XP threshold with increasing curve (harder to level up)
                state.xpToNextLevel = Math.round(state.xpToNextLevel * 1.5);
                state.xp = carryover;
                
                // Level up bonus
                const levelBonus = state.level * 25;
                state.credits += levelBonus;
                
                showNotification(`ðŸŽ® LEVEL UP! You're now level ${state.level}! +${levelBonus} credits bonus!`);
            }
            
            saveState();
        }

        // Calculate task rarity based on importance, time and deadline proximity
        function calculateTaskRarity(importance, timeEstimate, deadline) {
            const daysRemaining = Math.max(0, (new Date(deadline) - new Date()) / (1000 * 60 * 60 * 24));
            const urgencyFactor = Math.max(1, 3 - (daysRemaining / 7)); // Higher urgency for closer deadlines
            
            // Task difficulty score (0-100)
            const difficultyScore = (importance * 15) + (timeEstimate * 5) + (urgencyFactor * 10);
            
            // Determine rarity
            if (difficultyScore >= 90) return 'legendary';
            if (difficultyScore >= 70) return 'epic';
            if (difficultyScore >= 50) return 'rare';
            if (difficultyScore >= 30) return 'uncommon';
            return 'common';
        }
        
        // Calculate credits for a task with rarity modifier
        function calculateCredits(importance, timeEstimate, deadline, rarity) {
            const daysRemaining = Math.max(0, (new Date(deadline) - new Date()) / (1000 * 60 * 60 * 24));
            const urgencyFactor = Math.max(1, 3 - (daysRemaining / 7)); // Higher urgency for closer deadlines
            
            // Base formula with some randomness for variable rewards
            const variability = 0.9 + (Math.random() * 0.2); // 90%-110% variability
            
            // Rarity multipliers
            const rarityMultipliers = {
                'common': 1,
                'uncommon': 1.5,
                'rare': 2,
                'epic': 3,
                'legendary': 5
            };
            
            // Base credits calculation
            let baseCredits = (importance * 5 + Math.log(timeEstimate + 1) * 3) * urgencyFactor * variability;
            
            // Apply rarity modifier
            baseCredits *= rarityMultipliers[rarity];
            
            // Apply anti-farming diminishing returns
            const recentCompletions = countRecentCompletions();
            if (recentCompletions > 5) {
                const diminishingFactor = Math.max(0.5, 1 - ((recentCompletions - 5) * 0.05));
                baseCredits *= diminishingFactor;
            }
            
            return Math.round(baseCredits);
        }
        
        // Count recent task completions (anti-farming)
        function countRecentCompletions() {
            const now = new Date();
            const oneDayAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
            
            return state.completionHistory.filter(timestamp => {
                return new Date(timestamp) > oneDayAgo;
            }).length;
        }

        // Roll dice for critical success chance
        function rollDice() {
            const diceContainer = document.getElementById('diceRollDisplay');
            diceContainer.innerHTML = '';
            diceContainer.classList.add('show');
            
            // Create and show dice
            const dice = document.createElement('div');
            dice.className = 'dice';
            diceContainer.appendChild(dice);
            
            // Animate dice roll
            setTimeout(() => {
                const roll = Math.floor(Math.random() * 20) + 1; // d20
                dice.textContent = roll;
                
                // Determine if critical success
                let criticalSuccess = false;
                
                // Base 5% chance (roll of 20)
                if (roll === 20) {
                    criticalSuccess = true;
                } 
                // Streak increases critical chance
                else if (roll >= (20 - Math.min(5, Math.floor(state.streak / 2)))) {
                    criticalSuccess = true;
                }
                
                dice.style.background = criticalSuccess ? 'var(--legendary)' : 'var(--primary)';
                
                return criticalSuccess;
            }, 750);
            
            // Hide dice after animation
            setTimeout(() => {
                diceContainer.classList.remove('show');
            }, 3000);
        }

        // Show celebration/notification
        function showNotification(message, type = 'success') {
            const notificationEl = document.querySelector('.reward-notification');
            notificationEl.textContent = message;
            notificationEl.style.backgroundColor = type === 'success' ? 'var(--success)' : 'var(--primary)';
            
            document.querySelector('.celebration').style.opacity = '1';
            notificationEl.style.opacity = '1';
            notificationEl.style.transform = 'translateY(0)';
            
            setTimeout(() => {
                notificationEl.style.opacity = '0';
                notificationEl.style.transform = 'translateY(20px)';
                document.querySelector('.celebration').style.opacity = '0';
            }, 3000);
        }

        // Add task
        document.getElementById('taskForm').addEventListener('submit', (e) => {
            e.preventDefault();
            
            const importance = parseInt(document.getElementById('importance').value);
            const timeEstimate = parseFloat(document.getElementById('timeEstimate').value);
            const deadline = document.getElementById('deadline').value;
            
            // Calculate task rarity
            const rarity = calculateTaskRarity(importance, timeEstimate, deadline);
            
            const task = {
                name: document.getElementById('taskName').value,
                timeEstimate: timeEstimate,
                importance: importance,
                deadline: deadline,
                completed: false,
                rarity: rarity,
                credits: calculateCredits(importance, timeEstimate, deadline, rarity),
                xp: Math.round(importance * 10 + timeEstimate * 5), // Base XP
                created: new Date().toISOString()
            };
            
            state.tasks.push(task);
            saveState();
            updateUI();
            e.target.reset();
            
            showNotification(`New ${rarity} quest added: ${task.name}!`, 'primary');
        });

        // Add wishlist item with psychology-based credit formula
        document.getElementById('wishlistForm').addEventListener('submit', (e) => {
            e.preventDefault();
            
            const cost = parseFloat(document.getElementById('itemCost').value);
            const timeline = parseInt(document.getElementById('timeline').value);
            const desireLevel = parseInt(document.getElementById('desireLevel').value);
            
            // Base multiplier with variability
            const baseMultiplier = 9 + Math.random() * 2;
            
            // Progressive difficulty
            const difficultyMultiplier = state.wishlist.length === 0 ? 
                                        0.8 : // First item easier
                                        1 + (state.wishlist.length * 0.05); // Gets progressively harder
            
            // Timeline factor (longer timeline = more credits)
            const timelineFactor = 1 + (timeline / 20);
            
            // Desire discount (higher desire = slightly fewer credits)
            const desireMultiplier = 1.2 - (desireLevel * 0.08);
            
            // Calculate final credits
            const totalCredits = Math.round(cost * baseMultiplier * difficultyMultiplier * 
                                timelineFactor * desireMultiplier);
            
            // Endowed progress (small head start)
            const headStart = Math.min(0.05 * totalCredits, 50);
            
            const item = {
                name: document.getElementById('itemName').value,
                cost: cost,
                timeline: timeline,
                desireLevel: desireLevel,
                credits: totalCredits,
                progress: headStart,
                displayProgress: headStart / totalCredits,
                milestones: [0.25, 0.5, 0.75, 1], // Progress milestones at 25%, 50%, 75%, 100%
                created: new Date().toISOString()
            };
            
            // Apply the head start if user has enough credits
            if (state.credits >= headStart) {
                state.credits -= headStart;
                showNotification(`Got a head start on "${item.name}"!`, 'primary');
            } else {
                item.progress = state.credits;
                item.displayProgress = state.credits / totalCredits;
                state.credits = 0;
            }
            
            // Create a unique ID for this item
            item.id = Date.now().toString();
            
            // Initialize milestones tracking
            state.milestones[item.id] = [];
            
            state.wishlist.push(item);
            saveState();
            updateUI();
            e.target.reset();
            
            showNotification(`New reward added: ${item.name}`, 'primary');
        });

        // Complete task with chance for critical success
        function completeTask(index) {
            const task = state.tasks[index];
            if (!task.completed) {
                // Log completion time to history (for anti-farming)
                state.completionHistory.push(new Date().toISOString());
                
                // Roll dice for critical success
                const diceContainer = document.getElementById('diceRollDisplay');
                diceContainer.innerHTML = '';
                diceContainer.classList.add('show');
                
                // Create and show dice
                const dice = document.createElement('div');
                dice.className = 'dice';
                diceContainer.appendChild(dice);
                
                // Mark as completed first to prevent double-clicks
                task.completed = true;
                
                // Adjust completion UI
                const taskElements = document.querySelectorAll('.task-list li');
                if (taskElements[index]) {
                    const completeBtn = taskElements[index].querySelector('button');
                    if (completeBtn) {
                        completeBtn.disabled = true;
                        completeBtn.textContent = 'Rolling...';
                    }
                }
                
                // Animate dice roll
                setTimeout(() => {
                    // Roll the dice
                    const roll = Math.floor(Math.random() * 20) + 1; // d20
                    dice.textContent = roll;
                    
                    // Determine if critical success
                    let criticalSuccess = false;
                    let criticalFail = false;
                    
                    // Base critical chance
                    if (roll === 20) {
                        criticalSuccess = true;
                    } 
                    // Streak increases critical chance
                    else if (roll >= (20 - Math.min(5, Math.floor(state.streak / 2)))) {
                        criticalSuccess = true;
                    }
                    // Very small chance of critical fail
                    else if (roll === 1) {
                        criticalFail = true;
                    }
                    
                    // Apply streak bonus
                    let bonus = 1 + (state.streak * 0.1);
                    
                    // Apply early completion bonus
                    const daysEarly = Math.max(0, (new Date(task.deadline) - new Date()) / (1000 * 60 * 60 * 24));
                    const earlyBonus = daysEarly * 0.05;
                    bonus += earlyBonus;
                    
                    // Rarity multipliers for more variance
                    const rarityMultipliers = {
                        'common': 1,
                        'uncommon': 1.2,
                        'rare': 1.5,
                        'epic': 2,
                        'legendary': 3
                    };
                    
                    // Base credits calculation
                    let creditsEarned = Math.round(task.credits * bonus * rarityMultipliers[task.rarity]);
                    let xpEarned = task.xp;
                    
                    if (criticalSuccess) {
                        // Critical success - double rewards!
                        creditsEarned = Math.round(creditsEarned * 2);
                        xpEarned = Math.round(xpEarned * 2);
                        dice.style.background = 'var(--legendary)';
                        dice.style.boxShadow = '0 0 10px var(--legendary)';
                    } else if (criticalFail) {
                        // Critical fail - half rewards
                        creditsEarned = Math.round(creditsEarned * 0.5);
                        xpEarned = Math.round(xpEarned * 0.5);
                        dice.style.background = 'var(--danger)';
                    } else {
                        dice.style.background = 'var(--primary)';
                    }
                    
                    // Update player stats
                    state.credits += creditsEarned;
                    state.streak++;
                    state.lastStreak = new Date().toDateString();
                    addXP(xpEarned);
                    
                    // Show the result message
                    let message = '';
                    if (criticalSuccess) {
                        message = `ðŸŒŸ CRITICAL SUCCESS! +${creditsEarned} credits, +${xpEarned} XP`;
                    } else if (criticalFail) {
                        message = `ðŸ˜“ Critical fail... +${creditsEarned} credits, +${xpEarned} XP`;
                    } else {
                        message = `Quest completed! +${creditsEarned} credits, +${xpEarned} XP`;
                        if (state.streak > 1) {
                            message += ` (${state.streak}x streak bonus!)`;
                        }
                        if (earlyBonus > 0) {
                            message += ` (Early completion bonus!)`;
                        }
                    }
                    
                    // Chance for bonus loot for higher rarity tasks (Easter egg)
                    if (['rare', 'epic', 'legendary'].includes(task.rarity) && Math.random() < 0.3) {
                        const bonusCredits = Math.round(task.credits * 0.2);
                        state.credits += bonusCredits;
                        message += ` BONUS LOOT: +${bonusCredits} credits!`;
                    }
                    
                    // Show notification after roll
                    setTimeout(() => {
                        showNotification(message);
                    }, 500);
                    
                    saveState();
                    updateWishlistProgress();
                    updateUI();
                }, 750);
                
                // Hide dice after animation
                setTimeout(() => {
                    diceContainer.classList.remove('show');
                }, 3000);
            }
        }
        
        // Abandon task (with penalty)
        function abandonTask(index) {
            const task = state.tasks[index];
            if (!task.completed) {
                // Apply penalty
                const penalty = Math.round(task.credits * 0.25);
                state.credits = Math.max(0, state.credits - penalty);
                
                // Reset streak
                state.streak = 0;
                
                // Show notification
                showNotification(`Quest abandoned! -${penalty} credits. Streak reset!`, 'danger');
                
                // Remove task
                state.tasks.splice(index, 1);
                
                saveState();
                updateUI();
            }
        }

        // Update wishlist progress with psychological enhancements
        function updateWishlistProgress() {
            state.wishlist.forEach(item => {
                // Store previous progress for milestone checking
                const previousProgress = item.progress / item.credits;
                
                // Base progress as a proportion of total credits needed
                let baseProgress = Math.min(state.credits, item.credits - item.progress);
                
                // Goal-gradient effect - acceleration in final stretch
                if ((item.progress / item.credits) > 0.7 && (item.progress / item.credits) < 1) {
                    const goalGradientBonus = baseProgress * 0.1; // 10% bonus in final stretch
                    baseProgress += goalGradientBonus;
                }
                
                // Check if the user can allocate credits to this item
                if (baseProgress > 0) {
                    // Update item progress
                    item.progress += baseProgress;
                    state.credits -= baseProgress;
                    
                    // Update display progress with visual enhancement
                    item.displayProgress = Math.min(1, item.progress / item.credits);
                    
                    // Check for milestones
                    item.milestones.forEach(milestone => {
                        if (previousProgress < milestone && item.displayProgress >= milestone) {
                            if (!state.milestones[item.id] || !state.milestones[item.id].includes(milestone)) {
                                if (!state.milestones[item.id]) state.milestones[item.id] = [];
                                state.milestones[item.id].push(milestone);
                                
                                const percentComplete = Math.round(milestone * 100);
                                showNotification(`${percentComplete}% progress on "${item.name}"!`);
                                
                                // Add XP for milestone
                                if (milestone < 1) {
                                    addXP(Math.round(milestone * 50));
                                }
                            }
                        }
                    });
                    
                    // Check if item is now complete
                    if (item.displayProgress >= 1 && (!state.milestones[item.id] || !state.milestones[item.id].includes('completed'))) {
                        if (!state.milestones[item.id]) state.milestones[item.id] = [];
                        state.milestones[item.id].push('completed');
                        showNotification(`ðŸŽ‰ Reward unlocked: "${item.name}"! ðŸŽ‰`);
                        
                        // Bonus XP for completion
                        addXP(100);
                    }
                }
            });
            
            saveState();
        }

        // Update UI
        function updateUI() {
            // Update credits and level display
            document.getElementById('totalCredits').textContent = state.credits;
            document.getElementById('currentStreak').textContent = state.streak;
            document.getElementById('playerLevel').textContent = state.level;
            document.getElementById('currentXP').textContent = state.xp;
            document.getElementById('xpToNextLevel').textContent = state.xpToNextLevel;
            document.getElementById('levelProgress').style.width = `${(state.xp / state.xpToNextLevel) * 100}%`;

            // Update tasks list
            const taskList = document.getElementById('taskList');
            taskList.innerHTML = state.tasks
                .filter(task => !task.completed) // Show only uncompleted tasks
                .map((task, index) => {
                    const actualIndex = state.tasks.indexOf(task);
                    
                    // Format deadline with urgency coloring
                    const today = new Date();
                    const deadline = new Date(task.deadline);
                    const daysRemaining = Math.floor((deadline - today) / (1000 * 60 * 60 * 24));
                    
                    let deadlineClass = '';
                    if (daysRemaining < 0) {
                        deadlineClass = 'style="color: var(--danger); font-weight: bold;"';
                    } else if (daysRemaining < 2) {
                        deadlineClass = 'style="color: var(--warning); font-weight: bold;"';
                    }
                    
                    // Determine streak bonus
                    const streakBonus = Math.round(task.credits * state.streak * 0.1);
                    
                    // Get rarity name with proper capitalization
                    const rarityName = task.rarity.charAt(0).toUpperCase() + task.rarity.slice(1);
                    
                    return `
                    <li class="${task.rarity}">
                        <div class="task-info">
                            <strong>${task.name}</strong> <span style="font-size: 0.8em; color: var(--${task.rarity === 'common' ? 'secondary' : task.rarity});">[${rarityName}]</span><br>
                            ${task.importance}â˜… | ${task.timeEstimate}h | Due: <span ${deadlineClass}>${task.deadline}</span><br>
                            Reward: ${task.credits} credits (+${streakBonus} streak bonus), ${task.xp} XP
                            <div class="tooltip">â“˜
                                <span class="tooltiptext">
                                    Critical success chance: ${5 + Math.min(5, Math.floor(state.streak / 2))}%<br>
                                    Critical rewards: 2x credits & XP
                                </span>
                            </div>
                        </div>
                        <div class="task-buttons">
                            <button onclick="completeTask(${actualIndex})" style="background: var(--success);">Complete</button>
                            <button onclick="abandonTask(${actualIndex})" style="background: var(--danger);">Abandon</button>
                        </div>
                    </li>
                `})
                .join('');

            // Add completed tasks at the bottom (show only most recent 5)
            const completedTasks = state.tasks
                .filter(task => task.completed)
                .sort((a, b) => new Date(b.completed) - new Date(a.completed))
                .slice(0, 5)
                .map((task) => `
                    <li style="opacity: 0.7;" class="${task.rarity}">
                        <div>
                            <strong>${task.name}</strong> <span style="font-size: 0.8em; color: var(--${task.rarity === 'common' ? 'secondary' : task.rarity});">[${task.rarity.charAt(0).toUpperCase() + task.rarity.slice(1)}]</span><br>
                            ${task.importance}â˜… | ${task.timeEstimate}h | Completed
                        </div>
                        <span style="color: var(--success)">âœ“ Done</span>
                    </li>
                `)
                .join('');
                
            if (completedTasks) {
                taskList.innerHTML += `<h4>Completed quests</h4>${completedTasks}`;
            }

            // Update wishlist with enhanced progress display
            const wishlist = document.getElementById('wishlist');
            wishlist.innerHTML = state.wishlist
                .map((item, index) => {
                    // Build milestone markers
                    const milestonesHTML = item.milestones
                        .map(milestone => `
                            <div class="milestone" style="left: ${milestone * 100}%;"></div>
                        `)
                        .join('');
                    
                    // Calculate progress and display progress
                    const progressPercent = (item.progress / item.credits) * 100;
                    const displayProgressPercent = item.displayProgress * 100;
                    
                    // Check if item is complete
                    const isComplete = displayProgressPercent >= 100;
                    
                    return `
                    <li>
                        <div style="width: 100%;">
                            <strong>${item.name}</strong> ${isComplete ? 'âœ…' : ''}
                            <br>
                            ${item.cost} HKD | ${item.timeline} weeks | Desire: ${item.desireLevel}/5
                            <br>
                            ${Math.round(progressPercent)}% complete | ${Math.round(item.progress)}/${item.credits} credits
                            <div class="progress-bar" style="position: relative;">
                                ${milestonesHTML}
                                <div class="progress-bar-fill" style="width: ${Math.min(100, displayProgressPercent)}%"></div>
                            </div>
                        </div>
                    </li>
                `})
                .join('');
        }

        // Initialize
        loadState();

        // Daily credit decay (check on page load)
        const lastDecay = localStorage.getItem('lastCreditDecay');
        const now = new Date().toDateString();
        if (lastDecay !== now) {
            // Apply a small decay to maintain engagement
            state.credits = Math.max(0, Math.round(state.credits * 0.98));
            localStorage.setItem('lastCreditDecay', now);
            saveState();
        }

        // Auto-update wishlist progress when page loads
        updateWishlistProgress();
        updateUI();
    </script>

</body></html>